<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple IPTV Test</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
            background: #0f172a;
            color: #f9fafb;
            font-size: 28px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 95%;
            margin: 0 auto;
            padding: 24px 40px 32px;
            min-height: 100vh;
            background: rgba(15, 23, 42, 0.3);
        }
        
        h1 {
            margin-bottom: 20px;
            color: #e5f3ff;
            font-size: 48px;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            text-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
        }
        
        .controls {
            background: rgba(15, 23, 42, 0.96);
            padding: 16px 18px;
            border-radius: 10px;
            margin-bottom: 16px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.6);
            border: 1px solid #1f2937;
        }
        
        .controls input {
            flex: 1 1 320px;
            max-width: 100%;
            padding: 10px 12px;
            background: #020617;
            border: 1px solid #4b5563;
            color: #e5e7eb;
            border-radius: 6px;
            font-size: 24px;
            outline: none;
            transition: border-color 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
        }
        
        .controls input::placeholder {
            color: #6b7280;
        }
        
        .controls input:focus {
            border-color: #0ea5e9;
            box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.4);
            background-color: #020a16;
        }
        
        .controls button {
            padding: 12px 26px;
            background: linear-gradient(135deg, #0ea5e9, #22c1c3);
            border: none;
            color: #0b1120;
            border-radius: 999px;
            cursor: pointer;
            font-size: 22px;
            font-weight: 600;
            margin-left: 4px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            box-shadow: 0 10px 25px rgba(14, 165, 233, 0.55);
            transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
            white-space: nowrap;
        }
        
        .controls button:hover {
            background: linear-gradient(135deg, #38bdf8, #4ade80);
            box-shadow: 0 14px 30px rgba(34, 197, 235, 0.75);
            transform: translateY(-1px);
        }
        
        .controls button:active {
            transform: translateY(0);
            box-shadow: 0 6px 18px rgba(15, 118, 110, 0.7);
        }
        
        .controls button:focus {
            outline: 2px solid #e0f2fe;
            outline-offset: 2px;
        }
        
        .status {
            margin: 10px 0 4px;
            padding: 10px 12px;
            background: linear-gradient(90deg, rgba(56, 189, 248, 0.12), rgba(15, 23, 42, 0.95));
            border-radius: 8px;
            font-size: 24px;
            border: 1px solid #1f2937;
            color: #e5f3ff;
        }
        .error {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.16), rgba(15, 23, 42, 0.95));
            color: #fee2e2;
            border-color: #7f1d1d;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .app-header h1 {
            flex: 1;
        }
        
        .date-time {
            font-size: 32px;
            color: #9ca3af;
            font-weight: 500;
            letter-spacing: 0.02em;
            text-align: right;
        }
        
        .date-time .time {
            color: #60a5fa;
            font-size: 40px;
            font-weight: 600;
            margin-right: 12px;
        }

        .settings-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            padding: 0;
            border-radius: 999px;
            font-size: 55px !important;
            line-height: 1;
            box-shadow: 0 8px 20px rgba(15, 23, 42, 0.9);
        }

        .settings-panel {
            margin-bottom: 12px;
        }

        .settings-panel-inner {
            background: rgba(15, 23, 42, 0.96);
            border-radius: 10px;
            padding: 14px 16px 16px;
            border: 1px solid #1f2937;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.7);
        }

        .settings-title {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            margin: 14px 0 6px;
        }

        .mode-btn {
            padding: 8px 18px;
        }

        .categories {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            margin: 18px 0 12px;
            overflow-x: auto;
            overflow-y: visible;
            padding: 4px 0 8px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        .categories::-webkit-scrollbar {
            display: none; /* Chrome, Safari, webOS */
        }
        
        .category-btn {
            padding: 8px 20px;
            background: rgba(15, 23, 42, 0.92);
            border: 1px solid #374151;
            color: #e5e7eb;
            border-radius: 999px;
            cursor: pointer;
            font-size: 28px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            transition: background-color 0.15s ease, border-color 0.15s ease, transform 0.08s ease, box-shadow 0.15s ease;
            flex: 0 0 auto;
        }
        
        .category-btn:hover {
            background: #111827;
            border-color: #0ea5e9;
            box-shadow: 0 6px 16px rgba(15, 118, 110, 0.65);
            transform: translateY(-1px);
        }
        
        .category-btn:focus {
            outline: none;
            background: #0ea5e9;
            border-color: #e0f2fe;
            color: #02131f;
            transform: scale(1.05);
            box-shadow: 0 0 0 2px rgba(148, 231, 255, 0.9), 0 10px 26px rgba(14, 165, 233, 0.75);
        }
        
        .category-btn.active {
            background: #0ea5e9;
            border-color: #38bdf8;
            color: #02131f;
        }
        
        .channel-grid {
            margin-top: 18px;
            min-height: 400px;
            background: rgba(15, 23, 42, 0.3);
            padding: 20px;
            border-radius: 10px;
        }
        
        .channel-group-section {
            margin-bottom: 26px;
        }
        
        .group-header {
            font-size: 22px;
            font-weight: 600;
            color: #9beafe;
            margin-bottom: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1f2937;
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }
        
        .group-channels {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 16px;
            align-items: stretch;
        }
        
        .group-channels.list-mode {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .channel-card {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(17, 24, 39, 0.9));
            padding: 14px 16px;
            border-radius: 10px;
            cursor: pointer;
            border: 1px solid #020617;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.65);
            transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease, background-color 0.12s ease;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 70px;
        }
        
        .channel-card.list-mode {
            flex-direction: row;
            align-items: center;
            min-height: 80px;
            padding: 16px 22px;
        }
        
        .channel-info {
            flex: 0 0 320px;
            display: flex;
            flex-direction: column;
        }
        
        .epg-info {
            flex: 1;
            margin-left: 28px;
            padding-left: 28px;
            border-left: 1px solid #374151;
        }
        
        .epg-title {
            font-size: 32px;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 8px;
        }
        
        .epg-time {
            font-size: 24px;
            color: #9ca3af;
            margin-bottom: 10px;
        }
        
        .epg-desc {
            font-size: 26px;
            color: #d1d5db;
            line-height: 1.5;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .channel-card:hover {
            background: linear-gradient(135deg, #020617, #0f172a);
            border-color: #0ea5e9;
            box-shadow: 0 16px 36px rgba(15, 23, 42, 0.9);
            transform: translateY(-1px);
        }
        
        .channel-card:focus {
            outline: none;
            border-color: #e0f2fe;
            background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.35), rgba(15, 23, 42, 0.98));
            transform: scale(1.03);
            box-shadow: 0 0 0 2px rgba(148, 231, 255, 0.9), 0 20px 40px rgba(15, 23, 42, 0.95);
        }
        
        .channel-name {
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 26px;
            color: #f9fafb;
        }
        
        .channel-group {
            color: #9ca3af;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 0.13em;
        }
        
        .channel-epg {
            margin-top: 8px;
            color: #60a5fa;
            font-size: 16px;
            font-style: italic;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        #player-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: black;
            z-index: 1000;
        }
        
        #player-container.active {
            display: flex;
            flex-direction: column;
        }
        
        .player-header {
            background: linear-gradient(90deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
            padding: 14px 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #020617;
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.85);
        }
        
        #close-player {
            padding: 9px 18px;
            background: linear-gradient(135deg, #f97373, #ef4444);
            border: none;
            color: #fef2f2;
            border-radius: 999px;
            cursor: pointer;
            font-size: 22px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            box-shadow: 0 10px 26px rgba(185, 28, 28, 0.85);
            transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
        }
        
        #video-player {
            flex: 1;
            width: 100%;
            background: black;
        }
        
        .video-info {
            position: absolute;
            top: 60px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
        }
        
        .env-info {
            margin-top: 10px;
            padding: 8px;
            background: #222;
            border-radius: 4px;
            font-size: 13px;
            font-family: monospace;
            color: #aaa;
            word-break: break-all;
        }

        .progress-container {
            margin: 6px 0 2px;
            height: 6px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            overflow: hidden;
            border: 1px solid #0f172a;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, #0ea5e9, #22c55e);
            box-shadow: 0 0 10px rgba(34, 197, 235, 0.65);
            transition: width 0.18s ease-out;
        }

        .landing {
            margin-top: 32px;
            padding: 32px 26px 30px;
            border-radius: 14px;
            background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.25), rgba(15, 23, 42, 0.96));
            border: 1px solid rgba(15, 23, 42, 0.95);
            box-shadow: 0 26px 70px rgba(15, 23, 42, 0.95);
        }

        .landing-title {
            font-size: 36px;
            font-weight: 600;
            margin-bottom: 10px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: #e5f3ff;
        }

        .landing-subtitle {
            font-size: 24px;
            color: #cbd5f5;
            margin-bottom: 18px;
        }

        .landing-steps {
            font-size: 22px;
            color: #cbd5f5;
            margin-bottom: 18px;
        }

        .landing-steps li {
            margin-bottom: 4px;
        }

        .landing-hint {
            font-size: 18px;
            color: #9ca3af;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div class="container" role="main">
        <div class="app-header">
            <h1>Simple IPTV Test App</h1>
            <div class="date-time" id="date-time">
                <span class="time" id="time-display">00:00</span>
                <span id="date-display">Loading...</span>
            </div>
            <button id="settings-btn" class="category-btn settings-btn" tabindex="0" aria-label="Settings">⚙</button>
        </div>

        <div class="settings-panel" id="settings-panel" hidden>
            <div class="settings-panel-inner">
                <h2 class="settings-title">Settings</h2>
                <div class="controls">
                    <input 
                        type="text" 
                        id="m3u-url" 
                        placeholder="Enter M3U URL"
                        value="https://scoasttech.net:2096/get.php?username=shane.wilson.75@gmail.com&password=CV7OJYb6jV&type=m3u_plus&output=ts"
                    />
                    <button id="load-btn" tabindex="0">Load Playlist</button>
                    <button id="clear-btn" tabindex="0">Clear Cache</button>
                </div>
                <div class="controls">
                    <input 
                        type="text" 
                        id="epg-url" 
                        placeholder="Enter EPG URL (optional)"
                        value="https://scoasttech.net:2096/xmltv.php?username=shane.wilson.75@gmail.com&password=CV7OJYb6jV"
                    />
                    <button id="load-epg-btn" tabindex="0">Load EPG</button>
                </div>
                <div class="env-info" id="env-info"></div>
            </div>
        </div>
        
        <div class="status" id="status" aria-live="polite">Ready. Click "Load Playlist" to import channels.</div>
        <div class="progress-container" id="import-progress" style="display:none;">
            <div class="progress-bar" id="import-progress-bar"></div>
        </div>

        <div class="mode-toggle" id="mode-toggle" aria-label="Content type">
            <button id="mode-live" class="category-btn mode-btn active" tabindex="0">Live TV</button>
            <button id="mode-vod" class="category-btn mode-btn" tabindex="0">VOD</button>
        </div>

        <div class="landing" id="landing">
            <h2 class="landing-title">Your channels, one click away</h2>
            <p class="landing-subtitle">Press the settings gear to import your IPTV playlist, then browse channels by category using your remote.</p>
            <ul class="landing-steps">
                <li>1. Open <strong>Settings</strong> (⚙) in the top-right.</li>
                <li>2. Paste or confirm your M3U playlist URL.</li>
                <li>3. Choose <strong>Load Playlist</strong> and start watching.</li>
            </ul>
            <p class="landing-hint">Tip: Use arrow keys and OK to navigate. Back closes the player and settings.</p>
        </div>
        
        <div class="categories" id="categories" style="display:none;" aria-label="Channel categories"></div>
        
        <div class="channel-grid" id="channel-grid" style="display:none;"></div>
    </div>
    
    <div id="player-container">
        <div class="player-header">
            <h2 id="player-title">Channel</h2>
            <button id="close-player" tabindex="0">Close (Press Back)</button>
        </div>
        <div class="video-info" id="video-info">Loading...</div>
        <video id="video-player" controls autoplay></video>
    </div>

    <script>
        let channels = [];
        let hls = null;
        let selectedCategory = 'All';
        let currentMode = 'live'; // 'live' or 'vod'
        let epgData = {}; // Store EPG data by channel ID
        
        function detectChannelType(name, group) {
            const text = ((name || '') + ' ' + (group || '')).toLowerCase();
            const groupLower = (group || '').toLowerCase();
            
            // If group starts with "LIVE:" or common country/region prefixes, it's live TV
            const livePrefix = /^(live|uk|us|ca|au|int|nz|eir|int)[\s:]/i;
            if (livePrefix.test(group || '')) {
                return 'live';
            }
            
            const vodKeywords = [
                'vod',
                'video on demand',
                'on demand',
                'movie',
                'movies',
                'film',
                'films',
                'series',
                'boxset',
                'boxsets',
                'box set',
                'box sets',
                'catchup',
                'catch up',
                'catch-up'
            ];
            
            // Check for VOD keywords
            for (let i = 0; i < vodKeywords.length; i++) {
                if (text.indexOf(vodKeywords[i]) !== -1) {
                    return 'vod';
                }
            }
            
            // Check if group appears to be a genre-only category (typical for VOD organization)
            const genreOnlyKeywords = [
                'action',
                'adventure',
                'comedy',
                'drama',
                'thriller',
                'horror',
                'romance',
                'fantasy',
                'sci-fi',
                'animation',
                'documentary'
            ];
            
            for (let i = 0; i < genreOnlyKeywords.length; i++) {
                // Match whole words to avoid false positives
                const regex = new RegExp('\\b' + genreOnlyKeywords[i] + '\\b', 'i');
                if (regex.test(groupLower)) {
                    return 'vod';
                }
            }
            
            return 'live';
        }

        function normalizeChannelTypes(list) {
            if (!Array.isArray(list)) return [];
            for (let i = 0; i < list.length; i++) {
                const ch = list[i];
                ch.type = detectChannelType(ch.name, ch.group);
            }
            return list;
        }

        function getChannelsForCurrentMode() {
            if (!Array.isArray(channels)) return [];
            if (currentMode === 'vod') {
                return channels.filter(ch => ch.type === 'vod');
            }
            // Treat missing/unknown type as live by default
            return channels.filter(ch => ch.type !== 'vod');
        }

        // Parse XMLTV EPG data
        function parseXMLTV(xmlContent) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
            const programmes = xmlDoc.getElementsByTagName('programme');
            const epg = {};
            
            for (let i = 0; i < programmes.length; i++) {
                const prog = programmes[i];
                const channel = prog.getAttribute('channel');
                const start = prog.getAttribute('start');
                const stop = prog.getAttribute('stop');
                
                const titleEl = prog.getElementsByTagName('title')[0];
                const descEl = prog.getElementsByTagName('desc')[0];
                
                if (!channel || !start) continue;
                
                const title = titleEl ? titleEl.textContent : 'Unknown';
                const desc = descEl ? descEl.textContent : '';
                
                // Convert XMLTV time format (YYYYMMDDHHmmss +TZ) to timestamp
                const startTime = parseXMLTVTime(start);
                const stopTime = stop ? parseXMLTVTime(stop) : null;
                
                if (!epg[channel]) epg[channel] = [];
                epg[channel].push({
                    title,
                    desc,
                    start: startTime,
                    stop: stopTime
                });
            }
            
            // Sort programs by start time
            Object.keys(epg).forEach(channel => {
                epg[channel].sort((a, b) => a.start - b.start);
            });
            
            console.log('EPG data loaded for channels:', Object.keys(epg).slice(0, 10));
            console.log('Total EPG channels:', Object.keys(epg).length);
            
            return epg;
        }
        
        function parseXMLTVTime(xmltvTime) {
            // Format: YYYYMMDDHHmmss +HHMM
            const year = xmltvTime.substring(0, 4);
            const month = xmltvTime.substring(4, 6);
            const day = xmltvTime.substring(6, 8);
            const hour = xmltvTime.substring(8, 10);
            const minute = xmltvTime.substring(10, 12);
            const second = xmltvTime.substring(12, 14);
            
            const dateStr = `${year}-${month}-${day}T${hour}:${minute}:${second}`;
            return new Date(dateStr).getTime();
        }
        
        function getCurrentProgram(channelId, channelName) {
            const now = Date.now();
            let programs = null;
            let matchedChannel = null;
            
            // Try exact match with tvg-id first
            if (channelId && epgData[channelId]) {
                programs = epgData[channelId];
                matchedChannel = channelId;
            }
            // Try exact match by channel name
            else if (channelName && epgData[channelName]) {
                programs = epgData[channelName];
                matchedChannel = channelName;
            }
            // Try fuzzy matching
            else if (channelName) {
                // Extract core channel name - remove prefixes, suffixes, and normalize
                const normalized = channelName
                    .replace(/^(CA|UK|US|AU|NZ|INT|EIR):\s*/i, '') // Remove country prefix
                    .replace(/\s*\(.*?\)/g, '') // Remove parentheses content like (EAST)
                    .replace(/\s*HD$/i, '')
                    .replace(/\s*FHD$/i, '')
                    .replace(/\s*SD$/i, '')
                    .replace(/\s*4K$/i, '')
                    .replace(/\s+/g, '') // Remove all spaces
                    .trim()
                    .toLowerCase();
                
                // Search EPG data - extract core name from domain-style IDs
                for (const epgChannel in epgData) {
                    // Extract the main part before the domain (e.g., "animalplanet" from "animalplanet.us")
                    const epgCore = epgChannel
                        .replace(/\.(uk|us|ca|au|nz|int)$/i, '') // Remove country domain
                        .replace(/hd$/i, '')
                        .replace(/fhd$/i, '')
                        .replace(/sd$/i, '')
                        .replace(/plus1$/i, '')
                        .replace(/\+1$/i, '')
                        .toLowerCase();
                    
                    if (normalized === epgCore || normalized.includes(epgCore) || epgCore.includes(normalized)) {
                        programs = epgData[epgChannel];
                        matchedChannel = epgChannel;
                        console.log(`  ✓ Matched "${channelName}" to EPG channel "${epgChannel}"`);
                        break;
                    }
                }
            }
            
            if (!programs || programs.length === 0) return null;
            
            // Try to find currently airing program
            for (let i = 0; i < programs.length; i++) {
                const prog = programs[i];
                if (prog.start <= now && (!prog.stop || prog.stop >= now)) {
                    return prog;
                }
            }
            
            // If no current program, find the closest one (next or most recent)
            let closest = programs[0];
            let closestDiff = Math.abs(programs[0].start - now);
            
            for (let i = 1; i < programs.length; i++) {
                const diff = Math.abs(programs[i].start - now);
                if (diff < closestDiff) {
                    closest = programs[i];
                    closestDiff = diff;
                }
            }
            
            // Mark it as not current by adding a flag
            return { ...closest, notCurrent: true };
        }
        
        // Load EPG from URL
        async function loadEPG() {
            const url = document.getElementById('epg-url').value;
            if (!url) {
                updateStatus('Error: Please enter an EPG URL');
                return;
            }
            
            updateStatus('Loading EPG data...');
            startProgress();
            updateProgress(10);
            
            try {
                let fetchUrl = url;
                const host = (window.location && window.location.hostname) || '';
                if (host === 'localhost' || host === '127.0.0.1') {
                    fetchUrl = `/proxy?url=${encodeURIComponent(url)}`;
                }

                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                updateProgress(40);
                const content = await response.text();

                updateProgress(70);
                epgData = parseXMLTV(content);
                
                const channelCount = Object.keys(epgData).length;
                if (channelCount === 0) {
                    throw new Error('No EPG data found');
                }
                
                // Log sample for debugging
                const sampleChannels = Object.keys(epgData).slice(0, 5);
                console.log('Sample EPG channels:', sampleChannels);
                sampleChannels.forEach(ch => {
                    if (epgData[ch][0]) {
                        console.log(`  ${ch}: ${epgData[ch][0].title}`);
                    }
                });
                
                // Save EPG URL for auto-refresh on startup
                try {
                    localStorage.setItem('simple-iptv-epg-url', url);
                } catch (e) {
                    console.warn('Could not save EPG URL:', e);
                }
                
                updateProgress(100);
                updateStatus(`Loaded EPG data for ${channelCount} channels`);
                finishProgress();
                
                // Re-render channels to show EPG info
                renderChannels();
            } catch (error) {
                updateStatus(`EPG Error: ${error.message}`);
                console.error(error);
                finishProgress(true);
            }
        }

        // Load channels from localStorage
        function loadFromCache() {
            const cached = localStorage.getItem('simple-iptv-channels');
            if (cached) {
                try {
                    channels = JSON.parse(cached);
                    channels = normalizeChannelTypes(channels);
                    renderChannels();
                    renderCategories();
                    updateStatus(`Loaded ${channels.length} channels from cache`);
                } catch (e) {
                    console.error('Cache corrupted:', e);
                    localStorage.clear();
                }
            }
            
            // Restore EPG URL
            const cachedEPGUrl = localStorage.getItem('simple-iptv-epg-url');
            if (cachedEPGUrl) {
                const epgInput = document.getElementById('epg-url');
                if (epgInput) epgInput.value = cachedEPGUrl;
            }
        }
        
        // Parse M3U content
        function parseM3U(content, maxChannels = 1000) {
            const lines = content.split('\n');
            const parsed = [];
            let currentChannel = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('#EXTINF:')) {
                    const nameMatch = line.match(/tvg-name="([^"]+)"/) || line.match(/,(.+)$/);
                    const logoMatch = line.match(/tvg-logo="([^"]+)"/);
                    const groupMatch = line.match(/group-title="([^"]+)"/);
                    const tvgIdMatch = line.match(/tvg-id="([^"]+)"/);
                    
                    const name = nameMatch ? (nameMatch[1] || 'Unknown') : 'Unknown';
                    const group = groupMatch ? groupMatch[1] : 'General';
                    const tvgId = tvgIdMatch ? tvgIdMatch[1] : null;

                    currentChannel = {
                        name: name,
                        // Don't store logos to save space
                        group: group,
                        type: detectChannelType(name, group),
                        tvgId: tvgId
                    };
                } else if (line && !line.startsWith('#') && currentChannel) {
                    currentChannel.url = line;
                    parsed.push(currentChannel);
                    currentChannel = null;
                    
                    // Limit channels to prevent quota errors
                    if (parsed.length >= maxChannels) {
                        console.log(`Limiting to ${maxChannels} channels to save storage`);
                        break;
                    }
                }
            }
            
            return parsed;
        }
        
        // Load M3U from URL
        async function loadPlaylist() {
            const url = document.getElementById('m3u-url').value;
            if (!url) {
                updateStatus('Error: Please enter a URL');
                return;
            }
            
            updateStatus('Loading playlist...');
            startProgress();
            updateProgress(10);
            
            try {
                // When running in a browser on localhost, use the Node server proxy
                let fetchUrl = url;
                const host = (window.location && window.location.hostname) || '';
                if (host === 'localhost' || host === '127.0.0.1') {
                    fetchUrl = `/proxy?url=${encodeURIComponent(url)}`;
                }

                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                updateProgress(35);
                const content = await response.text();

                updateProgress(60);
                channels = parseM3U(content);
                channels = normalizeChannelTypes(channels);
                
                // Log sample for debugging EPG matching
                console.log('Sample channels with tvg-id:');
                channels.slice(0, 5).forEach(ch => {
                    console.log(`  ${ch.name} -> tvg-id: ${ch.tvgId || '(none)'}`);
                });
                
                if (channels.length === 0) {
                    throw new Error('No channels found in playlist');
                }
                
                // Try to save to localStorage with quota handling
                try {
                    localStorage.setItem('simple-iptv-channels', JSON.stringify(channels));
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        updateStatus(`Warning: Storage quota exceeded. Using first 500 channels.`);
                        channels = channels.slice(0, 500);
                        try {
                            localStorage.setItem('simple-iptv-channels', JSON.stringify(channels));
                        } catch (e2) {
                            updateStatus(`Error: Cannot store channels. Storage full.`);
                            // Don't save, just display
                        }
                    } else {
                        throw e;
                    }
                }
                
                updateProgress(85);
                renderChannels();
                renderCategories();
                updateProgress(100);
                updateStatus(`Loaded ${channels.length} channels successfully`);
                finishProgress();
            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                console.error(error);
                finishProgress(true);
            }
        }

        function startProgress() {
            const container = document.getElementById('import-progress');
            const bar = document.getElementById('import-progress-bar');
            if (!container || !bar) return;
            bar.style.width = '0%';
            container.style.display = 'block';
        }

        function updateProgress(value) {
            const bar = document.getElementById('import-progress-bar');
            if (!bar) return;
            const clamped = Math.max(0, Math.min(100, value));
            bar.style.width = clamped + '%';
        }

        function finishProgress(isError) {
            const container = document.getElementById('import-progress');
            if (!container) return;
            if (!isError) {
                updateProgress(100);
            }
            setTimeout(() => {
                container.style.display = 'none';
            }, 600);
        }
        
        // Render channel grid
        function renderChannels() {
            const grid = document.getElementById('channel-grid');
            const landing = document.getElementById('landing');
            const categoriesEl = document.getElementById('categories');

            if (!channels || channels.length === 0) {
                if (grid) grid.style.display = 'none';
                if (categoriesEl) categoriesEl.style.display = 'none';
                if (landing) landing.style.display = 'block';
                grid.innerHTML = '';
                return;
            }

            if (landing) landing.style.display = 'none';
            if (grid) grid.style.display = 'block';
            if (categoriesEl) categoriesEl.style.display = 'flex';
            grid.innerHTML = '';
            
            const base = getChannelsForCurrentMode();
            const filtered = selectedCategory === 'All' 
                ? base 
                : base.filter(ch => ch.group === selectedCategory);
            
            if (filtered.length === 0) {
                grid.innerHTML = '<div style="padding:40px; text-align:center; color:#888;">No channels in this category</div>';
                return;
            }
            
            // When "All" is selected, group channels by category
            if (selectedCategory === 'All') {
                // Debug EPG matching
                if (Object.keys(epgData).length > 0) {
                    console.log('EPG data available. First EPG channel:', Object.keys(epgData)[0]);
                    console.log('First playlist channel:', filtered[0] ? filtered[0].name : 'none');
                    console.log('First playlist tvgId:', filtered[0] ? filtered[0].tvgId : 'none');
                }
                
                // Group channels by category
                const groupedChannels = {};
                filtered.forEach(channel => {
                    if (!groupedChannels[channel.group]) {
                        groupedChannels[channel.group] = [];
                    }
                    groupedChannels[channel.group].push(channel);
                });
                
                // Sort group names
                const sortedGroups = Object.keys(groupedChannels).sort();
                
                // Render each group
                sortedGroups.forEach(groupName => {
                    const section = document.createElement('div');
                    section.className = 'channel-group-section';
                    
                    const header = document.createElement('div');
                    header.className = 'group-header';
                    header.textContent = `${groupName} (${groupedChannels[groupName].length})`;
                    section.appendChild(header);
                    
                    const groupGrid = document.createElement('div');
                    const hasEPG = Object.keys(epgData).length > 0 && currentMode === 'live';
                    groupGrid.className = hasEPG ? 'group-channels list-mode' : 'group-channels';
                    
                    groupedChannels[groupName].forEach(channel => {
                        const card = document.createElement('div');
                        card.className = hasEPG ? 'channel-card list-mode' : 'channel-card';
                        card.tabIndex = 0;
                        card.setAttribute('role', 'button');
                        card.setAttribute('aria-label', `${channel.name} (${channel.group})`);
                        
                        const currentProg = getCurrentProgram(channel.tvgId, channel.name);
                        
                        // Debug EPG matching for first few channels
                        if (groupedChannels[groupName].indexOf(channel) < 2) {
                            console.log(`Channel: ${channel.name}, tvgId: ${channel.tvgId || '(none)'}, EPG found:`, !!currentProg);
                            if (currentProg) {
                                console.log('  Program:', currentProg.title, 'Start:', new Date(currentProg.start));
                            }
                            // Try to find what EPG keys might match
                            const allEpgKeys = Object.keys(epgData);
                            const possibleMatches = allEpgKeys.filter(key => 
                                key.toLowerCase().includes(channel.name.toLowerCase().substring(4, 10)) ||
                                channel.name.toLowerCase().includes(key.toLowerCase().substring(0, 6))
                            );
                            if (possibleMatches.length > 0) {
                                console.log('  Possible EPG matches:', possibleMatches.slice(0, 3));
                            }
                        }
                        
                        if (hasEPG && currentProg) {
                            const startTime = new Date(currentProg.start).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                            const stopTime = currentProg.stop ? new Date(currentProg.stop).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : '';
                            const timeStr = stopTime ? `${startTime} - ${stopTime}` : startTime;
                            
                            card.innerHTML = `
                                <div class="channel-info">
                                    <div class="channel-name">${escapeHtml(channel.name)}</div>
                                    <div class="channel-group">${escapeHtml(channel.group)}</div>
                                </div>
                                <div class="epg-info">
                                    <div class="epg-title">${escapeHtml(currentProg.title)}</div>
                                    <div class="epg-time">${timeStr}</div>
                                    ${currentProg.desc ? `<div class="epg-desc">${escapeHtml(currentProg.desc)}</div>` : ''}
                                </div>
                            `;
                        } else if (hasEPG) {
                            card.innerHTML = `
                                <div class="channel-info">
                                    <div class="channel-name">${escapeHtml(channel.name)}</div>
                                    <div class="channel-group">${escapeHtml(channel.group)}</div>
                                </div>
                                <div class="epg-info">
                                    <div class="epg-time" style="color: #6b7280;">No program info</div>
                                </div>
                            `;
                        } else {
                            card.innerHTML = `
                                <div class="channel-name">${escapeHtml(channel.name)}</div>
                                <div class="channel-group">${escapeHtml(channel.group)}</div>
                            `;
                        }
                        
                        card.onclick = () => playChannel(channel);
                        card.onkeydown = (e) => {
                            if (e.key === 'Enter') playChannel(channel);
                        };
                        groupGrid.appendChild(card);
                    });
                    
                    section.appendChild(groupGrid);
                    grid.appendChild(section);
                });
            } else {
                // Single category view - use same structure as "All" for consistency
                const section = document.createElement('div');
                section.className = 'channel-group-section';
                
                const header = document.createElement('div');
                header.className = 'group-header';
                header.textContent = `${selectedCategory} (${filtered.length})`;
                section.appendChild(header);
                
                const groupGrid = document.createElement('div');
                const hasEPG = Object.keys(epgData).length > 0 && currentMode === 'live';
                groupGrid.className = hasEPG ? 'group-channels list-mode' : 'group-channels';
                
                filtered.forEach((channel, index) => {
                    const card = document.createElement('div');
                    card.className = hasEPG ? 'channel-card list-mode' : 'channel-card';
                    card.tabIndex = 0;
                    card.setAttribute('role', 'button');
                    card.setAttribute('aria-label', `${channel.name} (${channel.group})`);
                    
                    const currentProg = getCurrentProgram(channel.tvgId, channel.name);
                    
                    if (hasEPG && currentProg) {
                        const startTime = new Date(currentProg.start).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                        const stopTime = currentProg.stop ? new Date(currentProg.stop).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : '';
                        const timeStr = stopTime ? `${startTime} - ${stopTime}` : startTime;
                        
                        card.innerHTML = `
                            <div class="channel-info">
                                <div class="channel-name">${escapeHtml(channel.name)}</div>
                                <div class="channel-group">${escapeHtml(channel.group)}</div>
                            </div>
                            <div class="epg-info">
                                <div class="epg-title">${escapeHtml(currentProg.title)}</div>
                                <div class="epg-time">${timeStr}</div>
                                ${currentProg.desc ? `<div class="epg-desc">${escapeHtml(currentProg.desc)}</div>` : ''}
                            </div>
                        `;
                    } else if (hasEPG) {
                        card.innerHTML = `
                            <div class="channel-info">
                                <div class="channel-name">${escapeHtml(channel.name)}</div>
                                <div class="channel-group">${escapeHtml(channel.group)}</div>
                            </div>
                            <div class="epg-info">
                                <div class="epg-time" style="color: #6b7280;">No program info</div>
                            </div>
                        `;
                    } else {
                        card.innerHTML = `
                            <div class="channel-name">${escapeHtml(channel.name)}</div>
                            <div class="channel-group">${escapeHtml(channel.group)}</div>
                        `;
                    }
                    
                    card.onclick = () => playChannel(channel);
                    card.onkeydown = (e) => {
                        if (e.key === 'Enter') playChannel(channel);
                    };
                    groupGrid.appendChild(card);
                });
                
                section.appendChild(groupGrid);
                grid.appendChild(section);
            }
        }
        
        // Render category buttons
        function renderCategories() {
            const container = document.getElementById('categories');
            if (!container) return;
            container.innerHTML = '';

            const base = getChannelsForCurrentMode();
            if (!base || base.length === 0) {
                return;
            }
            
            // Get unique categories for current mode
            const categorySet = {};
            for (let i = 0; i < base.length; i++) {
                const g = base[i].group || 'General';
                categorySet[g] = true;
            }
            const groups = Object.keys(categorySet).sort();
            const categories = ['All'].concat(groups);
            
            categories.forEach(category => {
                const btn = document.createElement('button');
                btn.className = 'category-btn' + (category === selectedCategory ? ' active' : '');
                const count = category === 'All'
                    ? base.length
                    : base.filter(ch => ch.group === category).length;
                btn.textContent = `${category} (${count})`;
                btn.tabIndex = 0;
                btn.onclick = (e) => {
                    selectedCategory = category;
                    renderCategories();
                    renderChannels();
                    updateStatus(`Showing ${category} ${currentMode === 'vod' ? 'VOD' : 'Live TV'} channels`);
                    // Keep focus on the clicked category button
                    const targetBtn = e.currentTarget;
                    if (targetBtn) {
                        setTimeout(() => {
                            targetBtn.focus();
                        }, 0);
                    }
                };
                container.appendChild(btn);
            });
        }

        function setMode(mode) {
            if (mode !== 'live' && mode !== 'vod') return;
            if (currentMode === mode) return;
            currentMode = mode;

            const liveBtn = document.getElementById('mode-live');
            const vodBtn = document.getElementById('mode-vod');
            if (liveBtn && vodBtn) {
                if (mode === 'live') {
                    liveBtn.classList.add('active');
                    vodBtn.classList.remove('active');
                } else {
                    vodBtn.classList.add('active');
                    liveBtn.classList.remove('active');
                }
            }

            // Reset category to All when switching modes to avoid empty views
            selectedCategory = 'All';
            renderCategories();
            renderChannels();
            updateStatus(`Showing ${mode === 'vod' ? 'VOD' : 'Live TV'} channels`);
        }
        
        // Play channel
        function playChannel(channel) {
            const playerContainer = document.getElementById('player-container');
            const video = document.getElementById('video-player');
            const title = document.getElementById('player-title');
            
            console.log('Playing channel:', channel.name, 'URL:', channel.url);
            
            playerContainer.classList.add('active');
            title.textContent = channel.name;
            
            // Clean up previous HLS instance
            if (hls) {
                hls.destroy();
                hls = null;
            }
            
            video.src = '';
            video.load();
            
            // Play stream
            const streamUrl = channel.url;
            const isHLS = streamUrl.includes('.m3u8') || streamUrl.includes('m3u8');
            
            console.log('Stream type:', isHLS ? 'HLS' : 'Direct', 'HLS.isSupported:', Hls.isSupported());
            
            if (isHLS && Hls.isSupported()) {
                console.log('Using HLS.js');
                hls = new Hls({
                    enableWorker: false,
                    backBufferLength: 30,
                    maxBufferLength: 30,
                    debug: false
                });
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('Manifest parsed, starting playback');
                    video.play().catch(e => console.error('Play failed:', e));
                });
                
                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS Error:', data.type, data.details);
                    if (data.fatal) {
                        console.error('Fatal error:', data);
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.log('Network error, trying to recover...');
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log('Media error, trying to recover...');
                                hls.recoverMediaError();
                                break;
                            default:
                                console.error('Cannot recover from error');
                                updateStatus(`Error: ${data.details}`);
                                break;
                        }
                    }
                });
                
                hls.loadSource(streamUrl);
                hls.attachMedia(video);
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                console.log('Using native HLS');
                video.src = streamUrl;
                video.play().catch(e => console.error('Play failed:', e));
            } else {
                console.log('Direct video playback');
                video.src = streamUrl;
                video.play().catch(e => console.error('Play failed:', e));
            }
            
            video.onerror = (e) => {
                console.error('Video error:', e, 'Network state:', video.networkState, 'Ready state:', video.readyState);
                updateStatus(`Video error: ${video.error ? video.error.message : 'Unknown'}`);
            };
            
            video.onloadedmetadata = () => {
                console.log('Video metadata loaded:', video.videoWidth, 'x', video.videoHeight);
            };
            
            video.oncanplay = () => {
                console.log('Video can play');
            };
            
            updateStatus(`Playing: ${channel.name}`);
        }
        
        // Close player
        function closePlayer() {
            const playerContainer = document.getElementById('player-container');
            const video = document.getElementById('video-player');
            
            playerContainer.classList.remove('active');
            video.pause();
            
            if (hls) {
                hls.destroy();
                hls = null;
            }
        }
        
        // Update status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Update date and time display
        function updateDateTime() {
            const now = new Date();
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            const dayName = days[now.getDay()];
            const month = months[now.getMonth()];
            const date = now.getDate();
            const year = now.getFullYear();
            
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            
            const timeEl = document.getElementById('time-display');
            const dateEl = document.getElementById('date-display');
            
            if (timeEl) timeEl.textContent = `${hours}:${minutes}`;
            if (dateEl) dateEl.textContent = `${dayName}, ${month} ${date}, ${year}`;
        }
        
        // Update time every second
        setInterval(updateDateTime, 1000);
        updateDateTime(); // Initial update

        // Show environment info (user agent and HLS capabilities)
        function showEnvironmentInfo() {
            const infoEl = document.getElementById('env-info');
            if (!infoEl) return;
            
            const ua = navigator.userAgent || 'Unknown';
            const tempVideo = document.createElement('video');
            const hlsJsSupported = typeof Hls !== 'undefined' && Hls.isSupported && Hls.isSupported();
            const nativeHls = !!(
                tempVideo.canPlayType && (
                    tempVideo.canPlayType('application/vnd.apple.mpegurl') ||
                    tempVideo.canPlayType('application/x-mpegURL')
                )
            );
            
            const lines = [
                `UA: ${ua}`,
                `Hls.js supported: ${hlsJsSupported}`,
                `Native HLS support: ${nativeHls}`
            ];
            
            console.log('Environment info:', { ua, hlsJsSupported, nativeHls });
            infoEl.innerHTML = lines.map(line => escapeHtml(line)).join('<br>');
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Clear cache
        function clearCache() {
            localStorage.clear();
            channels = [];
            selectedCategory = 'All';
            renderChannels();
            renderCategories();
            updateStatus('Cache cleared');
        }

        // Settings toggle
        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            if (!panel) return;
            const isHidden = panel.hasAttribute('hidden');
            if (isHidden) {
                panel.removeAttribute('hidden');
                const input = document.getElementById('m3u-url');
                if (input) {
                    input.focus();
                }
            } else {
                panel.setAttribute('hidden', 'hidden');
            }
        }
        
        // Event listeners
        document.getElementById('load-btn').onclick = loadPlaylist;
        document.getElementById('load-epg-btn').onclick = loadEPG;
        document.getElementById('clear-btn').onclick = clearCache;
        document.getElementById('close-player').onclick = closePlayer;
        document.getElementById('settings-btn').onclick = toggleSettings;

        const modeLiveBtn = document.getElementById('mode-live');
        const modeVodBtn = document.getElementById('mode-vod');
        if (modeLiveBtn) {
            modeLiveBtn.onclick = () => setMode('live');
        }
        if (modeVodBtn) {
            modeVodBtn.onclick = () => setMode('vod');
        }
        
        // Remote control navigation
        document.addEventListener('keydown', (e) => {
            const playerContainer = document.getElementById('player-container');
            const isPlayerActive = playerContainer.classList.contains('active');
            const settingsPanel = document.getElementById('settings-panel');
            const isSettingsOpen = settingsPanel && !settingsPanel.hasAttribute('hidden');
            
            // Back button - Exit player or close settings
            if (e.key === 'Escape' || e.key === 'Backspace' || e.keyCode === 461) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                if (isPlayerActive) {
                    closePlayer();
                    return false;
                }
                if (isSettingsOpen) {
                    toggleSettings();
                    return false;
                }
                return false;
            }
            
            // Don't handle navigation when player is active
            if (isPlayerActive) return;
            
            // Arrow key navigation
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();
                const focused = document.activeElement;
                
                if (!focused || (!focused.classList.contains('channel-card') && !focused.classList.contains('category-btn'))) {
                    // Focus first element if nothing is focused
                    const firstCard = document.querySelector('.channel-card');
                    if (firstCard) firstCard.focus();
                    return;
                }
                
                // Get all focusable elements
                const allElements = Array.from(document.querySelectorAll('.category-btn, .channel-card'));
                const currentIndex = allElements.indexOf(focused);
                
                if (currentIndex === -1) return;
                
                const rect = focused.getBoundingClientRect();
                let bestIndex = -1;
                let bestDistance = Infinity;
                
                // Find best element in the direction
                allElements.forEach((element, index) => {
                    if (index === currentIndex) return;
                    
                    const targetRect = element.getBoundingClientRect();
                    let isValid = false;
                    let distance = 0;
                    
                    if (e.key === 'ArrowUp') {
                        isValid = targetRect.bottom <= rect.top + 10;
                        distance = rect.top - targetRect.bottom + Math.abs(targetRect.left - rect.left) * 0.3;
                    } else if (e.key === 'ArrowDown') {
                        isValid = targetRect.top >= rect.bottom - 10;
                        distance = targetRect.top - rect.bottom + Math.abs(targetRect.left - rect.left) * 0.3;
                    } else if (e.key === 'ArrowLeft') {
                        isValid = targetRect.right <= rect.left + 10;
                        distance = rect.left - targetRect.right + Math.abs(targetRect.top - rect.top) * 0.3;
                    } else if (e.key === 'ArrowRight') {
                        isValid = targetRect.left >= rect.right - 10;
                        distance = targetRect.left - rect.right + Math.abs(targetRect.top - rect.top) * 0.3;
                    }
                    
                    if (isValid && distance < bestDistance) {
                        bestDistance = distance;
                        bestIndex = index;
                    }
                });
                
                if (bestIndex !== -1) {
                    allElements[bestIndex].focus();
                    allElements[bestIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                }
            }
            
            // Enter key - activate focused element
            if (e.key === 'Enter') {
                e.preventDefault();
                const focused = document.activeElement;
                if (focused) {
                    focused.click();
                }
            }
        }, true); // Use capture phase to intercept events before webOS
        
        // Load cached channels on startup and show environment info
        showEnvironmentInfo();
        loadFromCache();
        
        // Auto-refresh EPG if URL is configured
        const cachedEPGUrl = localStorage.getItem('simple-iptv-epg-url');
        if (cachedEPGUrl) {
            console.log('Auto-refreshing EPG data from configured URL...');
            setTimeout(() => {
                loadEPG();
            }, 1000); // Small delay to let the UI render first
        }
        
        console.log('Simple IPTV Test App Ready');
        console.log('Channels in cache:', channels.length);
    </script>
</body>
</html>
