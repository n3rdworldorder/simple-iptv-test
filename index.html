<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple IPTV Test</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        // Prevent default back button behavior when player is active
        var playerActive = false;
        var backButtonHandled = false;
        
        // Override history.back to intercept back button
        var originalBack = window.history.back;
        window.history.back = function() {
            console.log('history.back called, playerActive:', window.playerActive);
            if (window.playerActive) {
                console.log('Intercepting back - closing player');
                // Trigger our close player logic
                var closeEvent = new CustomEvent('closePlayer');
                document.dispatchEvent(closeEvent);
                return;
            }
            // Otherwise, call original
            originalBack.call(window.history);
        };
        
        document.addEventListener('webOSLaunch', function() {
            console.log('webOS Launch event');
        });
        document.addEventListener('webOSRelaunch', function() {
            console.log('webOS Relaunch event - bringing app to foreground');
            if (window.playerActive) {
                // App was relaunched while player active
                console.log('Player was active, staying in player view');
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
            background: #0f172a;
            color: #f9fafb;
            font-size: 28px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 95%;
            margin: 0 auto;
            padding: 24px 40px 32px;
            min-height: 100vh;
            background: rgba(15, 23, 42, 0.3);
        }
        
        h1 {
            margin-bottom: 20px;
            color: #e5f3ff;
            font-size: 48px;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            text-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
        }
        
        .controls {
            background: rgba(15, 23, 42, 0.96);
            padding: 16px 18px;
            border-radius: 10px;
            margin-bottom: 16px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.6);
            border: 1px solid #1f2937;
        }
        
        .controls input {
            flex: 1 1 320px;
            max-width: 100%;
            padding: 10px 12px;
            background: #020617;
            border: 1px solid #4b5563;
            color: #e5e7eb;
            border-radius: 6px;
            font-size: 24px;
            outline: none;
            transition: border-color 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
        }
        
        .controls input::placeholder {
            color: #6b7280;
        }
        
        .controls input:focus {
            border-color: #0ea5e9;
            box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.4);
            background-color: #020a16;
        }
        
        .controls button {
            padding: 12px 26px;
            background: linear-gradient(135deg, #0ea5e9, #22c1c3);
            border: none;
            color: #0b1120;
            border-radius: 999px;
            cursor: pointer;
            font-size: 22px;
            font-weight: 600;
            margin-left: 4px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            box-shadow: 0 10px 25px rgba(14, 165, 233, 0.55);
            transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
            white-space: nowrap;
        }
        
        .controls button:hover {
            background: linear-gradient(135deg, #38bdf8, #4ade80);
            box-shadow: 0 14px 30px rgba(34, 197, 235, 0.75);
            transform: translateY(-1px);
        }
        
        .controls button:active {
            transform: translateY(0);
            box-shadow: 0 6px 18px rgba(15, 118, 110, 0.7);
        }
        
        .controls button:focus {
            outline: 2px solid #e0f2fe;
            outline-offset: 2px;
        }
        
        .status {
            margin: 10px 0 4px;
            padding: 10px 12px;
            background: linear-gradient(90deg, rgba(56, 189, 248, 0.12), rgba(15, 23, 42, 0.95));
            border-radius: 8px;
            font-size: 28px;
            border: 1px solid #1f2937;
            color: #e5f3ff;
        }
        .error {
            background: linear-gradient(90deg, rgba(248, 113, 113, 0.16), rgba(15, 23, 42, 0.95));
            color: #fee2e2;
            border-color: #7f1d1d;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .app-header h1 {
            flex: 1;
        }
        
        .date-time {
            font-size: 32px;
            color: #9ca3af;
            font-weight: 500;
            letter-spacing: 0.02em;
            text-align: right;
            margin-right: 40px;
        }
        
        .date-time .time {
            color: #60a5fa;
            font-size: 40px;
            font-weight: 600;
            margin-right: 12px;
        }

        .settings-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 20px;
            border-radius: 999px;
            font-size: 22px !important;
            line-height: 1;
            box-shadow: 0 8px 20px rgba(15, 23, 42, 0.9);
        }

        .settings-btn.highlighted,
        .settings-btn.highlighted:focus {
            box-shadow: 0 14px 38px rgba(14,165,233,0.35), 0 6px 18px rgba(14,165,233,0.18) !important;
            transform: translateY(-2px) scale(1.02) !important;
            border: 1px solid rgba(14,165,233,0.9) !important;
            background: linear-gradient(135deg, #0ea5e9, #22c1c3) !important;
            color: #02131f !important;
        }

        .settings-panel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0f172a;
            z-index: 2000;
            overflow-y: auto;
        }
        
        .settings-panel.active {
            display: block;
        }

        .settings-panel-inner {
            max-width: 95%;
            margin: 0 auto;
            padding: 24px 40px 32px;
            min-height: 100vh;
        }

        .settings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .settings-title {
            font-size: 48px;
            font-weight: 600;
            color: #e5f3ff;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            text-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
        }
        
        .close-settings-btn {
            padding: 12px 26px;
            background: linear-gradient(135deg, #6b7280, #4b5563);
            border: none;
            color: #f9fafb;
            border-radius: 999px;
            cursor: pointer;
            font-size: 22px;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.55);
            transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
        }
        
        .close-settings-btn:hover {
            background: linear-gradient(135deg, #9ca3af, #6b7280);
            box-shadow: 0 14px 30px rgba(0, 0, 0, 0.75);
            transform: translateY(-1px);
        }
        
        .close-settings-btn:focus {
            outline: 2px solid #e0f2fe;
            outline-offset: 2px;
        }
        
        .settings-section-title {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 10px;
            margin-top: 20px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            margin: 14px 0 6px;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.2);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* smaller progress bar for settings panel */
        .progress-container.small { height: 8px; border-radius: 6px; background: rgba(255,255,255,0.06); overflow: hidden; }
        .progress-container.small .progress-bar { height: 100%; background: linear-gradient(90deg,#60a5fa,#3b82f6); width: 0%; transition: width 120ms linear; }

        /* Larger loading text in settings */
        #settings-import-status-text { font-size: 30px; font-weight: 700; color: #e6eefc; }
        /* EPG progress text in settings */
        #settings-epg-status-text { font-size: 30px; font-weight: 700; color: #e6eefc; }
        /* Larger status while loading on main screen */
        .status-large { font-size: 34px; font-weight: 700; }

        .mode-btn {
            padding: 8px 18px;
        }

        .categories {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            margin: 18px 0 12px;
            overflow-x: auto;
            overflow-y: visible;
            padding: 4px 8px 8px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        .categories::-webkit-scrollbar {
            display: none; /* Chrome, Safari, webOS */
        }
        
        .category-btn {
            padding: 8px 20px;
            background: rgba(15, 23, 42, 0.92);
            border: 1px solid #374151;
            color: #e5e7eb;
            border-radius: 999px;
            cursor: pointer;
            font-size: 28px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            transition: background-color 0.15s ease, border-color 0.15s ease, transform 0.08s ease, box-shadow 0.15s ease;
            flex: 0 0 auto;
        }
        
        .category-btn:hover {
            background: #111827;
            border-color: #0ea5e9;
            box-shadow: 0 6px 16px rgba(15, 118, 110, 0.65);
            transform: translateY(-1px);
        }
        
        .category-btn:focus {
            outline: none;
            background: #0ea5e9;
            border-color: #e0f2fe;
            color: #02131f;
            transform: scale(1.05);
            box-shadow: 0 0 0 2px rgba(148, 231, 255, 0.9), 0 10px 26px rgba(14, 165, 233, 0.75);
        }
        
        .category-btn.active {
            background: #0ea5e9;
            border-color: #38bdf8;
            color: #02131f;
        }
        
        .channel-grid {
            margin-top: 18px;
            min-height: 400px;
            background: rgba(15, 23, 42, 0.3);
            padding: 20px;
            border-radius: 10px;
        }
        
        .channel-group-section {
            margin-bottom: 26px;
        }
        
        .group-header {
            font-size: 22px;
            font-weight: 600;
            color: #9beafe;
            margin-bottom: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1f2937;
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }
        
        .group-channels {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 16px;
            align-items: stretch;
        }
        
        .group-channels.list-mode {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .channel-card {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(17, 24, 39, 0.9));
            padding: 14px 16px;
            border-radius: 10px;
            cursor: pointer;
            border: 1px solid #020617;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.65);
            transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease, background-color 0.12s ease;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 70px;
        }
        
        .channel-card.list-mode {
            flex-direction: row;
            align-items: center;
            min-height: 80px;
            padding: 16px 22px;
        }
        
        .channel-info {
            flex: 0 0 320px;
            display: flex;
            flex-direction: column;
        }
        
        .epg-info {
            flex: 1;
            margin-left: 28px;
            padding-left: 28px;
            border-left: 1px solid #374151;
        }
        
        .epg-title {
            font-size: 32px;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 8px;
        }
        
        .epg-time {
            font-size: 24px;
            color: #9ca3af;
            margin-bottom: 10px;
        }
        
        .epg-desc {
            font-size: 26px;
            color: #d1d5db;
            line-height: 1.5;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .channel-card:hover {
            background: linear-gradient(135deg, #020617, #0f172a);
            border-color: #0ea5e9;
            box-shadow: 0 16px 36px rgba(15, 23, 42, 0.9);
            transform: translateY(-1px);
        }
        
        .channel-card:focus {
            outline: none;
            border-color: #e0f2fe;
            background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.35), rgba(15, 23, 42, 0.98));
            transform: scale(1.03);
            box-shadow: 0 0 0 2px rgba(148, 231, 255, 0.9), 0 20px 40px rgba(15, 23, 42, 0.95);
        }
        
        .channel-name {
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 26px;
            color: #f9fafb;
        }
        
        .channel-group {
            color: #9ca3af;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 0.13em;
        }
        
        .channel-epg {
            margin-top: 8px;
            color: #60a5fa;
            font-size: 16px;
            font-style: italic;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        #player-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: black;
            z-index: 1000;
        }
        
        #player-container.active {
            display: flex;
            flex-direction: column;
        }
        
        .player-header {
            background: linear-gradient(90deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
            padding: 14px 18px;
            display: none;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #020617;
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.85);
        }
        
        #close-player {
            padding: 9px 18px;
            background: linear-gradient(135deg, #f97373, #ef4444);
            border: none;
            color: #fef2f2;
            border-radius: 999px;
            cursor: pointer;
            font-size: 22px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            box-shadow: 0 10px 26px rgba(185, 28, 28, 0.85);
            transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.08s ease;
        }
        
        #video-player {
            flex: 1;
            width: 100%;
            background: black;
        }
        
        .video-info {
            position: absolute;
            top: 60px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            display: none;
        }
        
        .env-info {
            margin-top: 10px;
            padding: 8px;
            background: #222;
            border-radius: 4px;
            font-size: 26px;
            font-family: monospace;
            color: #aaa;
            word-break: break-all;
        }

        .progress-container {
            margin: 6px 0 2px;
            height: 6px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            overflow: hidden;
            border: 1px solid #0f172a;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, #0ea5e9, #22c55e);
            box-shadow: 0 0 10px rgba(34, 197, 235, 0.65);
            transition: width 0.18s ease-out;
        }

        .landing {
            margin-top: 32px;
            padding: 32px 26px 30px;
            border-radius: 14px;
            background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.25), rgba(15, 23, 42, 0.96));
            border: 1px solid rgba(15, 23, 42, 0.95);
            box-shadow: 0 26px 70px rgba(15, 23, 42, 0.95);
        }

        .landing-title {
            font-size: 36px;
            font-weight: 600;
            margin-bottom: 10px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: #e5f3ff;
        }

        .landing-subtitle {
            font-size: 24px;
            color: #cbd5f5;
            margin-bottom: 18px;
        }

        .landing-steps {
            font-size: 33px;
            color: #cbd5f5;
            margin-bottom: 18px;
        }

        .landing-steps li {
            margin-bottom: 4px;
        }

        .landing-hint {
            font-size: 18px;
            color: #9ca3af;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .channel-banner {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0.4));
            padding: 30px 50px 35px;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            z-index: 100;
            min-height: 340px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            box-sizing: border-box;
        }

        .channel-banner.visible {
            transform: translateY(0);
        }
        
        .banner-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .banner-channel-name {
            font-size: 42px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
            flex: 1;
        }
        
        .banner-datetime {
            font-size: 32px;
            color: #9ca3af;
            text-align: right;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
            white-space: nowrap;
            margin-left: 40px;
        }
        
        .banner-datetime .banner-time {
            color: #60a5fa;
            font-size: 36px;
            font-weight: 600;
            display: block;
            margin-bottom: 4px;
        }

        .banner-program-section {
            margin-bottom: 20px;
        }
        
        .banner-program-section:last-of-type {
            margin-bottom: 0;
        }
        
        .banner-program-label {
            font-size: 24px;
            font-weight: 600;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
        }
        
        .banner-epg-title {
            font-size: 36px;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 6px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
        }

        .banner-epg-time {
            font-size: 28px;
            color: #9ca3af;
            margin-bottom: 8px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
        }

        .banner-epg-desc {
            font-size: 32px;
            color: #d1d5db;
            line-height: 1.5;
            max-width: 90%;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            text-overflow: ellipsis;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
        }
        
        .banner-progress {
            margin-top: 12px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 999px;
            overflow: hidden;
        }
        
        .banner-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0ea5e9, #22c55e);
            border-radius: 999px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(34, 197, 235, 0.65);
        }
        
        .banner-indicators {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 16px;
            min-height: 32px;
        }
        
        .banner-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .banner-indicator.active {
            background: #60a5fa;
            width: 14px;
            height: 14px;
            box-shadow: 0 0 10px rgba(96, 165, 250, 0.8);
        }
    </style>
</head>
<body>
    <div class="container" role="main">
        <div class="app-header">
            <h1>Simple IPTV Test App</h1>
            <div class="date-time" id="date-time">
                <span class="time" id="time-display">00:00</span>
                <span id="date-display">Loading...</span>
            </div>
            <button id="settings-btn" class="category-btn settings-btn" tabindex="0" aria-label="Settings">SETTINGS</button>
        </div>

        <div class="settings-panel" id="settings-panel">
            <div class="settings-panel-inner">
                <div class="settings-header">
                    <h1 class="settings-title">Settings</h1>
                    <button id="close-settings" class="close-settings-btn" tabindex="0">Close (Press Back)</button>
                </div>
                <h2 class="settings-section-title">Playlist</h2>
                <div class="controls">
                    <input 
                        type="text" 
                        id="m3u-url" 
                        placeholder="Enter M3U URL"
                        value="https://scoasttech.net:2096/get.php?username=shane.wilson.75@gmail.com&password=CV7OJYb6jV&type=m3u_plus&output=ts"
                    />
                    <button id="load-btn" tabindex="0">Load Playlist</button>
                        <button id="clear-btn" tabindex="0">Clear Cache</button>
                        <span id="load-spinner" class="spinner" style="display:none; margin-left:10px; vertical-align:middle;" aria-hidden="true"></span>
                </div>
                <div id="settings-import-status" style="display:none; margin-top:12px;">
                    <div class="progress-container small" id="settings-import-progress">
                        <div class="progress-bar" id="settings-import-progress-bar"></div>
                    </div>
                    <div id="settings-import-status-text" style="margin-top:6px; color:#cbd5e1;">Waiting</div>
                </div>
                <h2 class="settings-section-title">EPG (Program Guide)</h2>
                <div class="controls">
                    <input 
                        type="text" 
                        id="epg-url" 
                        placeholder="Enter EPG URL (optional)"
                        value="https://scoasttech.net:2096/xmltv.php?username=shane.wilson.75@gmail.com&password=CV7OJYb6jV"
                    />
                    <button id="load-epg-btn" tabindex="0">Load EPG</button>
                </div>
                <div id="settings-epg-import-status" style="display:none; margin-top:12px;">
                    <div class="progress-container small" id="settings-epg-progress">
                        <div class="progress-bar" id="settings-epg-progress-bar"></div>
                    </div>
                    <div id="settings-epg-status-text" style="margin-top:6px; color:#cbd5e1;">Waiting</div>
                </div>
                <h2 class="settings-section-title">Environment Info</h2>
                <div class="env-info" id="env-info"></div>
            </div>
        </div>
        
        <div class="status" id="status" aria-live="polite">Ready. Click "Load Playlist" to import channels.</div>
        <div class="progress-container" id="import-progress" style="display:none;">
            <div class="progress-bar" id="import-progress-bar"></div>
        </div>

        <div class="mode-toggle" id="mode-toggle" aria-label="Content type" style="display:none;">
            <button id="mode-live" class="category-btn mode-btn active" tabindex="0">Live TV</button>
            <button id="mode-vod" class="category-btn mode-btn" tabindex="0">VOD</button>
        </div>

        <div class="landing" id="landing">
            <h2 class="landing-title">Your channels, one click away</h2>
            <p class="landing-subtitle">Press the settings gear to import your IPTV playlist, then browse channels by category using your remote.</p>
            <ul class="landing-steps">
                <li>1. Open <strong>Settings</strong> (⚙) in the top-right.</li>
                <li>2. Paste or confirm your M3U playlist URL.</li>
                <li>3. Choose <strong>Load Playlist</strong> and start watching.</li>
            </ul>
            <p class="landing-hint">Tip: Use arrow keys and OK to navigate. Back closes the player and settings.</p>
        </div>
        
        <div class="categories" id="categories" style="display:none;" aria-label="Channel categories"></div>
        
        <div class="channel-grid" id="channel-grid" style="display:none;"></div>
    </div>
    
    <div id="player-container">
        <div class="player-header">
            <h2 id="player-title">Channel</h2>
            <button id="close-player" tabindex="0">Close (Press Back)</button>
        </div>
        <div class="video-info" id="video-info">Loading...</div>
        <video id="video-player" autoplay></video>
        <div class="channel-banner" id="channel-banner">
            <div class="banner-header">
                <div class="banner-channel-name" id="banner-channel-name"></div>
                <div class="banner-datetime" id="banner-datetime">
                    <span class="banner-time" id="banner-time"></span>
                    <span id="banner-date"></span>
                </div>
            </div>
            <div class="banner-program-section" id="banner-now-section">
                <div class="banner-program-label" id="banner-now-label">Now</div>
                <div class="banner-epg-title" id="banner-epg-title"></div>
                <div class="banner-epg-time" id="banner-epg-time"></div>
                <div class="banner-epg-desc" id="banner-epg-desc"></div>
                <div class="banner-progress" id="banner-progress" style="display: none;">
                    <div class="banner-progress-bar" id="banner-progress-bar" style="width: 0%;"></div>
                </div>
            </div>
            <div class="banner-program-section" id="banner-next-section" style="display: none;">
                <div class="banner-program-label" id="banner-next-label">Next</div>
                <div class="banner-epg-title" id="banner-next-title"></div>
                <div class="banner-epg-time" id="banner-next-time"></div>
                <div class="banner-epg-desc" id="banner-next-desc"></div>
                <div class="banner-progress" style="visibility: hidden;">
                    <div class="banner-progress-bar" style="width: 0%;"></div>
                </div>
            </div>
            <div class="banner-indicators" id="banner-indicators" style="display: none;">
                <div class="banner-indicator" id="indicator-now"></div>
                <div class="banner-indicator" id="indicator-next"></div>
            </div>
        </div>
    </div>

    <script>
        let channels = [];
        let hls = null;
        let selectedCategory = 'All';
        let currentMode = 'live'; // 'live' or 'vod'
        let epgData = {}; // Store EPG data by channel ID
        let currentPlayingChannel = null; // Track currently playing channel
        let currentChannelIndex = -1; // Track current channel index for channel navigation
        let bannerView = 'now'; // 'now' or 'next'
        let bannerTimeout = null;
        let bannerHasNext = false; // Track if next program exists
        
        function detectChannelType(name, group) {
            const text = ((name || '') + ' ' + (group || '')).toLowerCase();
            const groupLower = (group || '').toLowerCase();
            
            // If group starts with "LIVE:" or common country/region prefixes, it's live TV
            const livePrefix = /^(live|uk|us|ca|au|int|nz|eir|irl)[\s:]/i;
            if (livePrefix.test(group || '')) {
                return 'live';
            }
            
            const vodKeywords = [
                'vod',
                'video on demand',
                'on demand',
                'movie',
                'movies',
                'film',
                'films',
                'series',
                'boxset',
                'boxsets',
                'box set',
                'box sets',
                'catchup',
                'catch up',
                'catch-up',
                'disney',
                'netflix',
                'prime',
                'hulu',
                'family',
                'kids',
                'children',
                'cartoon',
                'anime'
            ];
            
            // Check for VOD keywords
            for (let i = 0; i < vodKeywords.length; i++) {
                if (text.indexOf(vodKeywords[i]) !== -1) {
                    return 'vod';
                }
            }
            
            // Check if group appears to be a genre-only category (typical for VOD organization)
            const genreOnlyKeywords = [
                'action',
                'adventure',
                'comedy',
                'drama',
                'thriller',
                'horror',
                'romance',
                'fantasy',
                'sci-fi',
                'animation',
                'documentary'
            ];
            
            for (let i = 0; i < genreOnlyKeywords.length; i++) {
                // Match whole words to avoid false positives
                const regex = new RegExp('\\b' + genreOnlyKeywords[i] + '\\b', 'i');
                if (regex.test(groupLower)) {
                    return 'vod';
                }
            }
            
            return 'live';
        }

        function normalizeChannelTypes(list) {
            if (!Array.isArray(list)) return [];
            for (let i = 0; i < list.length; i++) {
                const ch = list[i];
                ch.type = detectChannelType(ch.name, ch.group);
            }
            return list;
        }

        function getChannelsForCurrentMode() {
            if (!Array.isArray(channels)) return [];
            if (currentMode === 'vod') {
                return channels.filter(ch => ch.type === 'vod');
            }
            // Treat missing/unknown type as live by default
            return channels.filter(ch => ch.type !== 'vod');
        }

        // Parse XMLTV EPG data (async to allow UI updates)
        async function parseXMLTV(xmlContent, onProgress) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
            const programmes = xmlDoc.getElementsByTagName('programme');
            const epg = {};
            const total = programmes.length;
            
            for (let i = 0; i < programmes.length; i++) {
                const prog = programmes[i];
                const channel = prog.getAttribute('channel');
                const start = prog.getAttribute('start');
                const stop = prog.getAttribute('stop');
                
                const titleEl = prog.getElementsByTagName('title')[0];
                const descEl = prog.getElementsByTagName('desc')[0];
                
                if (!channel || !start) continue;
                
                const title = titleEl ? titleEl.textContent : 'Unknown';
                const desc = descEl ? descEl.textContent : '';
                
                // Convert XMLTV time format (YYYYMMDDHHmmss +TZ) to timestamp
                const startTime = parseXMLTVTime(start);
                const stopTime = stop ? parseXMLTVTime(stop) : null;
                
                if (!epg[channel]) epg[channel] = [];
                epg[channel].push({
                    title,
                    desc,
                    start: startTime,
                    stop: stopTime
                });
                
                // Yield control to allow UI updates every 500 items
                if (i % 500 === 0) {
                    if (onProgress) {
                        onProgress(i + 1, total);
                    }
                    // Yield to event loop to allow UI updates
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Final progress update
            if (onProgress) {
                onProgress(total, total);
            }
            
            // Sort programs by start time
            Object.keys(epg).forEach(channel => {
                epg[channel].sort((a, b) => a.start - b.start);
            });
            
            console.log('EPG data loaded for channels:', Object.keys(epg).slice(0, 10));
            console.log('Total EPG channels:', Object.keys(epg).length);
            
            return epg;
        }
        
        function parseXMLTVTime(xmltvTime) {
            // Format: YYYYMMDDHHmmss +HHMM
            const year = xmltvTime.substring(0, 4);
            const month = xmltvTime.substring(4, 6);
            const day = xmltvTime.substring(6, 8);
            const hour = xmltvTime.substring(8, 10);
            const minute = xmltvTime.substring(10, 12);
            const second = xmltvTime.substring(12, 14);
            
            const dateStr = `${year}-${month}-${day}T${hour}:${minute}:${second}`;
            return new Date(dateStr).getTime();
        }
        
        function getCurrentProgram(channelId, channelName) {
            const now = Date.now();
            let programs = null;
            let matchedChannel = null;
            
            // Try exact match with tvg-id first
            if (channelId && epgData[channelId]) {
                programs = epgData[channelId];
                matchedChannel = channelId;
            }
            // Try exact match by channel name
            else if (channelName && epgData[channelName]) {
                programs = epgData[channelName];
                matchedChannel = channelName;
            }
            // Try fuzzy matching
            else if (channelName) {
                // Extract core channel name - remove prefixes, suffixes, and normalize
                const normalized = channelName
                    .replace(/^(CA|UK|US|AU|NZ|INT|EIR):\s*/i, '') // Remove country prefix
                    .replace(/\s*\(.*?\)/g, '') // Remove parentheses content like (EAST)
                    .replace(/\s*HD$/i, '')
                    .replace(/\s*FHD$/i, '')
                    .replace(/\s*SD$/i, '')
                    .replace(/\s*4K$/i, '')
                    .replace(/\s+/g, '') // Remove all spaces
                    .trim()
                    .toLowerCase();
                
                // Search EPG data - extract core name from domain-style IDs
                for (const epgChannel in epgData) {
                    // Extract the main part before the domain (e.g., "animalplanet" from "animalplanet.us")
                    const epgCore = epgChannel
                        .replace(/\.(uk|us|ca|au|nz|int)$/i, '') // Remove country domain
                        .replace(/hd$/i, '')
                        .replace(/fhd$/i, '')
                        .replace(/sd$/i, '')
                        .replace(/plus1$/i, '')
                        .replace(/\+1$/i, '')
                        .toLowerCase();
                    
                    if (normalized === epgCore || normalized.includes(epgCore) || epgCore.includes(normalized)) {
                        programs = epgData[epgChannel];
                        matchedChannel = epgChannel;
                        console.log(`  ✓ Matched "${channelName}" to EPG channel "${epgChannel}"`);
                        break;
                    }
                }
            }
            
            if (!programs || programs.length === 0) return null;
            
            // Try to find currently airing program
            for (let i = 0; i < programs.length; i++) {
                const prog = programs[i];
                if (prog.start <= now && (!prog.stop || prog.stop >= now)) {
                    return prog;
                }
            }
            
            // If no current program, find the closest one (next or most recent)
            let closest = programs[0];
            let closestDiff = Math.abs(programs[0].start - now);
            
            for (let i = 1; i < programs.length; i++) {
                const diff = Math.abs(programs[i].start - now);
                if (diff < closestDiff) {
                    closest = programs[i];
                    closestDiff = diff;
                }
            }
            
            // Mark it as not current by adding a flag
            return { ...closest, notCurrent: true };
        }
        
        // Load EPG from URL
        async function loadEPG() {
            const url = document.getElementById('epg-url').value;
            if (!url) {
                updateStatus('Error: Please enter an EPG URL');
                return;
            }
            
            updateStatus('Downloading EPG data...');
            startProgress();
            updateProgress(10);
            // Show EPG progress in settings panel (non-invasive)
            startSettingsEPGProgress();
            updateSettingsEPGProgress(10, 'Starting EPG download...');
            
            try {
                let fetchUrl = url;
                const host = (window.location && window.location.hostname) || '';
                if (host === 'localhost' || host === '127.0.0.1') {
                    fetchUrl = `/proxy?url=${encodeURIComponent(url)}`;
                }

                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                // Get content length if available
                const contentLength = response.headers.get('Content-Length');
                const total = contentLength ? parseInt(contentLength, 10) : 0;
                
                let loaded = 0;
                const reader = response.body.getReader();
                const chunks = [];
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    loaded += value.length;
                    
                    const loadedMB = (loaded / (1024 * 1024)).toFixed(2);
                    if (total > 0) {
                        const totalMB = (total / (1024 * 1024)).toFixed(2);
                        const percent = Math.min(90, 10 + (loaded / total) * 60);
                        updateProgress(percent);
                        updateStatus(`Downloading EPG data... ${loadedMB} MB / ${totalMB} MB`);
                        updateSettingsEPGProgress(percent, `Downloading EPG data... ${loadedMB} MB / ${totalMB} MB`);
                    } else {
                        updateStatus(`Downloading EPG data... ${loadedMB} MB`);
                        // Animate progress without total
                        const percent = Math.min(60, 10 + (loaded / (1024 * 1024 * 100)) * 50);
                        updateProgress(percent);
                        updateSettingsEPGProgress(percent, `Downloading EPG data... ${loadedMB} MB`);
                    }
                }
                
                // Combine chunks into single string
                const allChunks = new Uint8Array(loaded);
                let position = 0;
                for (const chunk of chunks) {
                    allChunks.set(chunk, position);
                    position += chunk.length;
                }
                const content = new TextDecoder('utf-8').decode(allChunks);

                updateProgress(70);
                updateStatus('Parsing EPG data...');
                updateSettingsEPGProgress(70, 'Parsing EPG data...');
                
                // Small delay to ensure status is visible
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Parse with progress callback (now async)
                epgData = await parseXMLTV(content, (current, total) => {
                    const percent = 70 + Math.floor((current / total) * 25);
                    updateProgress(percent);
                    updateStatus(`Parsing EPG data... ${current.toLocaleString()} / ${total.toLocaleString()} programs`);
                    updateSettingsEPGProgress(percent, `Parsing EPG data... ${current.toLocaleString()} / ${total.toLocaleString()} programs`);
                });
                
                const channelCount = Object.keys(epgData).length;
                if (channelCount === 0) {
                    throw new Error('No EPG data found');
                }
                
                // Log sample for debugging
                const sampleChannels = Object.keys(epgData).slice(0, 5);
                console.log('Sample EPG channels:', sampleChannels);
                sampleChannels.forEach(ch => {
                    if (epgData[ch][0]) {
                        console.log(`  ${ch}: ${epgData[ch][0].title}`);
                    }
                });
                
                // Save EPG URL for auto-load on startup
                try {
                    localStorage.setItem('simple-iptv-epg-url', url);
                } catch (e) {
                    console.warn('Could not save EPG URL:', e);
                }
                
                updateProgress(100);
                updateStatus(`Loaded EPG data for ${channelCount} channels`);
                updateSettingsEPGProgress(100, `Loaded EPG data for ${channelCount} channels`);
                finishProgress();
                finishSettingsEPGProgress();
                
                // Re-render channels to show EPG info
                renderChannels();
            } catch (error) {
                updateStatus(`EPG Error: ${error.message}`);
                updateSettingsEPGProgress(100, `EPG Error: ${error.message}`);
                console.error(error);
                finishProgress(true);
                finishSettingsEPGProgress(true);
            }
        }

        // Load channels from localStorage
        function loadFromCache() {
            const cached = localStorage.getItem('simple-iptv-channels');
            if (cached) {
                try {
                    channels = JSON.parse(cached);
                    channels = normalizeChannelTypes(channels);
                    renderChannels();
                    renderCategories();
                    updateStatus(`Loaded ${channels.length} channels from cache`);
                } catch (e) {
                    console.error('Cache corrupted:', e);
                    localStorage.clear();
                }
            }
            
            // Restore EPG URL
            const cachedEPGUrl = localStorage.getItem('simple-iptv-epg-url');
            if (cachedEPGUrl) {
                const epgInput = document.getElementById('epg-url');
                if (epgInput) epgInput.value = cachedEPGUrl;
            }
        }
        
        // Parse M3U content with optional progress callback
        // onProgress receives (fraction 0..1, parsedCount)
        function parseM3U(content, maxChannels = 1000, onProgress) {
            const lines = content.split('\n');
            const parsed = [];
            let currentChannel = null;

            const total = lines.length || 1;
            // Only update UI at intervals to avoid thrashing
            const updateInterval = Math.max(1, Math.floor(total / 100));

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                if (line.startsWith('#EXTINF:')) {
                    const nameMatch = line.match(/tvg-name="([^"]+)"/) || line.match(/,(.+)$/);
                    const logoMatch = line.match(/tvg-logo="([^"]+)"/);
                    const groupMatch = line.match(/group-title="([^"]+)"/);
                    const tvgIdMatch = line.match(/tvg-id="([^"]+)"/);

                    const name = nameMatch ? (nameMatch[1] || 'Unknown') : 'Unknown';
                    const group = groupMatch ? groupMatch[1] : 'General';
                    const tvgId = tvgIdMatch ? tvgIdMatch[1] : null;

                    currentChannel = {
                        name: name,
                        // Don't store logos to save space
                        group: group,
                        type: detectChannelType(name, group),
                        tvgId: tvgId
                    };
                } else if (line && !line.startsWith('#') && currentChannel) {
                    currentChannel.url = line;
                    parsed.push(currentChannel);
                    currentChannel = null;

                    // Limit channels to prevent quota errors
                    if (parsed.length >= maxChannels) {
                        console.log(`Limiting to ${maxChannels} channels to save storage`);
                        break;
                    }
                }

                // report progress periodically
                if (onProgress && (i % updateInterval === 0 || i === total - 1)) {
                    try {
                        onProgress(i / total, parsed.length);
                    } catch (e) {
                        // ignore progress callback errors
                    }
                }
            }

            // finished
            if (onProgress) {
                try { onProgress(1, parsed.length); } catch (e) {}
            }

            return parsed;
        }
        
        // Load M3U from URL
        async function loadPlaylist() {
            const url = document.getElementById('m3u-url').value;
            if (!url) {
                updateStatus('Error: Please enter a URL');
                return;
            }
            
            // Disable load button and show progress UI
            const loadBtn = document.getElementById('load-btn');
            if (loadBtn) loadBtn.disabled = true;
            // Make main status text larger while loading
            const mainStatus = document.getElementById('status');
            if (mainStatus) mainStatus.classList.add('status-large');
            // settings panel progress
            startSettingsProgress();
            updateSettingsProgress(10, 'Starting...');
            updateStatus('Loading playlist...');
            startProgress();
            updateProgress(10);
            
            try {
                // When running in a browser on localhost, use the Node server proxy
                let fetchUrl = url;
                const host = (window.location && window.location.hostname) || '';
                if (host === 'localhost' || host === '127.0.0.1') {
                    fetchUrl = `/proxy?url=${encodeURIComponent(url)}`;
                }

                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                // Stream the playlist so we can report bytes downloaded
                const contentLength = response.headers.get('Content-Length');
                const totalBytes = contentLength ? parseInt(contentLength, 10) : 0;
                let loaded = 0;
                const reader = response.body && response.body.getReader ? response.body.getReader() : null;
                const chunks = [];

                updateProgress(35);
                updateSettingsProgress(35, 'Downloading playlist...');

                if (reader) {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        chunks.push(value);
                        loaded += value.length || value.byteLength || 0;

                        const loadedMB = (loaded / (1024 * 1024)).toFixed(2);
                        if (totalBytes > 0) {
                            const totalMB = (totalBytes / (1024 * 1024)).toFixed(2);
                            const percent = Math.min(60, 35 + Math.floor((loaded / totalBytes) * 25));
                            updateProgress(percent);
                            updateStatus(`Downloading playlist... ${loadedMB} MB / ${totalMB} MB`);
                            updateSettingsProgress(percent, `Downloading playlist... ${loadedMB} MB / ${totalMB} MB`);
                        } else {
                            const percent = Math.min(60, 35 + Math.floor((loaded / (1024 * 1024 * 100)) * 25));
                            updateProgress(percent);
                            updateStatus(`Downloading playlist... ${loadedMB} MB`);
                            updateSettingsProgress(percent, `Downloading playlist... ${loadedMB} MB`);
                        }
                    }

                    // Combine chunks into string
                    const allChunks = new Uint8Array(loaded);
                    let position = 0;
                    for (const chunk of chunks) {
                        allChunks.set(chunk, position);
                        position += chunk.length || chunk.byteLength || 0;
                    }
                    var content = new TextDecoder('utf-8').decode(allChunks);
                } else {
                    // Fallback for environments without streaming support
                    var content = await response.text();
                    loaded = content.length;
                }

                updateProgress(60);
                updateSettingsProgress(60, 'Preparing to parse...');
                // Provide incremental parsing progress (maps 0..1 -> 60..85)
                const estimatedTotal = (content.match(/#EXTINF:/g) || []).length;
                const totalDownloadedMB = (loaded / (1024 * 1024)).toFixed(2);
                // Show downloaded summary for at least 2 seconds before parsing
                try {
                    const downloadMsg = estimatedTotal > 0
                        ? `Downloaded ${totalDownloadedMB} MB — ${estimatedTotal} items found`
                        : `Downloaded ${totalDownloadedMB} MB`;
                    updateProgress(65);
                    updateStatus(downloadMsg);
                    updateSettingsProgress(65, downloadMsg);
                    // Ensure message is visible for minimum 2s
                    await new Promise(resolve => setTimeout(resolve, 3000));
                } catch (e) {
                    // ignore if sleep fails
                }

                channels = parseM3U(content, 1000, (p, parsedCount) => {
                    const pct = 60 + Math.round(p * 25);
                    updateProgress(pct);
                    // Update status with parsed channel count and estimated total and show spinner
                    const spinner = document.getElementById('load-spinner');
                    if (spinner) spinner.style.display = 'inline-block';
                    if (estimatedTotal > 0) {
                        const text = `Parsing playlist... (${parsedCount} / ${estimatedTotal}) — ${totalDownloadedMB} MB`;
                        updateStatus(text);
                        updateSettingsProgress(pct, text);
                    } else {
                        const text = `Parsing playlist... (${parsedCount} channels) — ${totalDownloadedMB} MB`;
                        updateStatus(text);
                        updateSettingsProgress(pct, text);
                    }
                });
                channels = normalizeChannelTypes(channels);
                
                // Log sample for debugging EPG matching
                console.log('Sample channels with tvg-id:');
                channels.slice(0, 5).forEach(ch => {
                    console.log(`  ${ch.name} -> tvg-id: ${ch.tvgId || '(none)'}`);
                });
                
                if (channels.length === 0) {
                    throw new Error('No channels found in playlist');
                }
                
                // Try to save to localStorage with quota handling
                try {
                    localStorage.setItem('simple-iptv-channels', JSON.stringify(channels));
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        updateStatus(`Warning: Storage quota exceeded. Using first 500 channels.`);
                        channels = channels.slice(0, 500);
                        try {
                            localStorage.setItem('simple-iptv-channels', JSON.stringify(channels));
                        } catch (e2) {
                            updateStatus(`Error: Cannot store channels. Storage full.`);
                            // Don't save, just display
                        }
                    } else {
                        throw e;
                    }
                }
                
                updateProgress(85);
                updateSettingsProgress(85, 'Saving channels...');
                renderChannels();
                renderCategories();
                updateProgress(100);
                const doneMsg = `Loaded ${channels.length} channels successfully`;
                updateStatus(doneMsg);
                updateSettingsProgress(100, doneMsg);
                finishProgress();
                finishSettingsProgress();
            } catch (error) {
                const errMsg = `Error: ${error.message}`;
                updateStatus(errMsg);
                updateSettingsProgress(100, errMsg);
                console.error(error);
                finishProgress(true);
                finishSettingsProgress(true);
            }
            finally {
                // Re-enable button regardless of success/failure
                const loadBtnFinally = document.getElementById('load-btn');
                if (loadBtnFinally) loadBtnFinally.disabled = false;
                const spinnerFinally = document.getElementById('load-spinner');
                if (spinnerFinally) spinnerFinally.style.display = 'none';
                if (mainStatus) mainStatus.classList.remove('status-large');
            }
        }

        function startProgress() {
            const container = document.getElementById('import-progress');
            const bar = document.getElementById('import-progress-bar');
            if (!container || !bar) return;
            bar.style.width = '0%';
            container.style.display = 'block';
        }

        // Settings-panel progress helpers
        function startSettingsProgress() {
            const container = document.getElementById('settings-import-progress');
            const wrapper = document.getElementById('settings-import-status');
            const statusText = document.getElementById('settings-import-status-text');
            if (!container || !wrapper) return;
            container.style.width = '100%';
            container.firstElementChild.style.width = '0%';
            wrapper.style.display = 'block';
            if (statusText) statusText.textContent = 'Starting...';
        }

        function updateSettingsProgress(value, text) {
            const bar = document.getElementById('settings-import-progress-bar');
            const statusText = document.getElementById('settings-import-status-text');
            if (!bar) return;
            const clamped = Math.max(0, Math.min(100, value));
            bar.style.width = clamped + '%';
            if (statusText && typeof text === 'string') statusText.textContent = text;
        }

        function finishSettingsProgress(isError) {
            const wrapper = document.getElementById('settings-import-status');
            const bar = document.getElementById('settings-import-progress-bar');
            const statusText = document.getElementById('settings-import-status-text');
            if (!wrapper || !bar) return;
            if (!isError) bar.style.width = '100%';
            setTimeout(() => {
                if (wrapper) wrapper.style.display = 'none';
                if (statusText) statusText.textContent = '';
            }, 700);
        }

        // Lightweight EPG progress helpers (separate from playlist progress)
        function startSettingsEPGProgress() {
            const container = document.getElementById('settings-epg-progress');
            const wrapper = document.getElementById('settings-epg-import-status');
            const statusText = document.getElementById('settings-epg-status-text');
            if (!container || !wrapper) return;
            container.style.width = '100%';
            const bar = container.querySelector('.progress-bar');
            if (bar) bar.style.width = '0%';
            wrapper.style.display = 'block';
            if (statusText) statusText.textContent = 'Starting...';
        }

        function updateSettingsEPGProgress(value, text) {
            const bar = document.getElementById('settings-epg-progress-bar');
            const statusText = document.getElementById('settings-epg-status-text');
            if (!bar) return;
            const clamped = Math.max(0, Math.min(100, value));
            bar.style.width = clamped + '%';
            if (statusText && typeof text === 'string') statusText.textContent = text;
        }

        function finishSettingsEPGProgress(isError) {
            const wrapper = document.getElementById('settings-epg-import-status');
            const bar = document.getElementById('settings-epg-progress-bar');
            const statusText = document.getElementById('settings-epg-status-text');
            if (!wrapper || !bar) return;
            if (!isError) bar.style.width = '100%';
            setTimeout(() => {
                if (wrapper) wrapper.style.display = 'none';
                if (statusText) statusText.textContent = '';
            }, 700);
        }

        function updateProgress(value) {
            const bar = document.getElementById('import-progress-bar');
            if (!bar) return;
            const clamped = Math.max(0, Math.min(100, value));
            bar.style.width = clamped + '%';
        }

        function finishProgress(isError) {
            const container = document.getElementById('import-progress');
            if (!container) return;
            if (!isError) {
                updateProgress(100);
            }
            setTimeout(() => {
                container.style.display = 'none';
            }, 600);
        }

        // Control mode-toggle visibility and persist preference
        function setModeToggleVisibility(visible) {
            const modeToggle = document.getElementById('mode-toggle');
            if (!modeToggle) return;
            modeToggle.style.display = visible ? 'flex' : 'none';
            try {
                localStorage.setItem('simple-iptv-mode-visible', visible ? '1' : '0');
            } catch (e) {
                // ignore storage errors
            }
        }
        
        // Render channel grid
        function renderChannels() {
            const grid = document.getElementById('channel-grid');
            const landing = document.getElementById('landing');
            const categoriesEl = document.getElementById('categories');
            const modeToggle = document.getElementById('mode-toggle');
            const statusEl = document.getElementById('status');

            if (!channels || channels.length === 0) {
                if (grid) grid.style.display = 'none';
                if (categoriesEl) categoriesEl.style.display = 'none';
                // Hide mode toggle when there are no channels
                if (typeof setModeToggleVisibility === 'function') {
                    setModeToggleVisibility(false);
                } else if (modeToggle) {
                    modeToggle.style.display = 'none';
                }
                // Hide status banner on main screen when no channel data
                if (statusEl) statusEl.style.display = 'none';
                if (landing) landing.style.display = 'block';
                grid.innerHTML = '';
                return;
            }

            if (landing) landing.style.display = 'none';
            if (grid) grid.style.display = 'block';
            // Show status banner when channels are present
            if (statusEl) statusEl.style.display = 'block';
            // Show mode toggle when channels are present
            if (typeof setModeToggleVisibility === 'function') {
                setModeToggleVisibility(true);
            } else if (modeToggle) {
                modeToggle.style.display = 'flex';
            }
            if (categoriesEl) categoriesEl.style.display = 'flex';
            grid.innerHTML = '';
            
            const base = getChannelsForCurrentMode();
            const filtered = selectedCategory === 'All' 
                ? base 
                : base.filter(ch => ch.group === selectedCategory);
            
            if (filtered.length === 0) {
                grid.innerHTML = '<div style="padding:40px; text-align:center; color:#888;">No channels in this category</div>';
                return;
            }
            
            // When "All" is selected, group channels by category
            if (selectedCategory === 'All') {
                // Debug EPG matching
                if (Object.keys(epgData).length > 0) {
                    console.log('EPG data available. First EPG channel:', Object.keys(epgData)[0]);
                    console.log('First playlist channel:', filtered[0] ? filtered[0].name : 'none');
                    console.log('First playlist tvgId:', filtered[0] ? filtered[0].tvgId : 'none');
                }
                
                // Group channels by category
                const groupedChannels = {};
                filtered.forEach(channel => {
                    if (!groupedChannels[channel.group]) {
                        groupedChannels[channel.group] = [];
                    }
                    groupedChannels[channel.group].push(channel);
                });
                
                // Sort group names
                const sortedGroups = Object.keys(groupedChannels).sort();
                
                // Render each group
                sortedGroups.forEach(groupName => {
                    const section = document.createElement('div');
                    section.className = 'channel-group-section';
                    
                    const header = document.createElement('div');
                    header.className = 'group-header';
                    header.textContent = `${groupName} (${groupedChannels[groupName].length})`;
                    section.appendChild(header);
                    
                    const groupGrid = document.createElement('div');
                    const hasEPG = Object.keys(epgData).length > 0 && currentMode === 'live';
                    groupGrid.className = hasEPG ? 'group-channels list-mode' : 'group-channels';
                    
                    groupedChannels[groupName].forEach(channel => {
                        const card = document.createElement('div');
                        card.className = hasEPG ? 'channel-card list-mode' : 'channel-card';
                        card.tabIndex = 0;
                        card.setAttribute('role', 'button');
                        card.setAttribute('aria-label', `${channel.name} (${channel.group})`);
                        
                        const currentProg = getCurrentProgram(channel.tvgId, channel.name);
                        
                        // Debug EPG matching for first few channels
                        if (groupedChannels[groupName].indexOf(channel) < 2) {
                            console.log(`Channel: ${channel.name}, tvgId: ${channel.tvgId || '(none)'}, EPG found:`, !!currentProg);
                            if (currentProg) {
                                console.log('  Program:', currentProg.title, 'Start:', new Date(currentProg.start));
                            }
                            // Try to find what EPG keys might match
                            const allEpgKeys = Object.keys(epgData);
                            const possibleMatches = allEpgKeys.filter(key => 
                                key.toLowerCase().includes(channel.name.toLowerCase().substring(4, 10)) ||
                                channel.name.toLowerCase().includes(key.toLowerCase().substring(0, 6))
                            );
                            if (possibleMatches.length > 0) {
                                console.log('  Possible EPG matches:', possibleMatches.slice(0, 3));
                            }
                        }
                        
                        if (hasEPG && currentProg) {
                            const startTime = new Date(currentProg.start).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                            const stopTime = currentProg.stop ? new Date(currentProg.stop).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : '';
                            const timeStr = stopTime ? `${startTime} - ${stopTime}` : startTime;
                            
                            card.innerHTML = `
                                <div class="channel-info">
                                    <div class="channel-name">${escapeHtml(channel.name)}</div>
                                    <div class="channel-group">${escapeHtml(channel.group)}</div>
                                </div>
                                <div class="epg-info">
                                    <div class="epg-title">${escapeHtml(currentProg.title)}</div>
                                    <div class="epg-time">${timeStr}</div>
                                    ${currentProg.desc ? `<div class="epg-desc">${escapeHtml(currentProg.desc)}</div>` : ''}
                                </div>
                            `;
                        } else if (hasEPG) {
                            card.innerHTML = `
                                <div class="channel-info">
                                    <div class="channel-name">${escapeHtml(channel.name)}</div>
                                    <div class="channel-group">${escapeHtml(channel.group)}</div>
                                </div>
                                <div class="epg-info">
                                    <div class="epg-time" style="color: #6b7280;">No program info</div>
                                </div>
                            `;
                        } else {
                            card.innerHTML = `
                                <div class="channel-name">${escapeHtml(channel.name)}</div>
                                <div class="channel-group">${escapeHtml(channel.group)}</div>
                            `;
                        }
                        
                        card.onclick = () => playChannel(channel);
                        card.onkeydown = (e) => {
                            if (e.key === 'Enter') playChannel(channel);
                        };
                        groupGrid.appendChild(card);
                    });
                    
                    section.appendChild(groupGrid);
                    grid.appendChild(section);
                });
            } else {
                // Single category view - use same structure as "All" for consistency
                const section = document.createElement('div');
                section.className = 'channel-group-section';
                
                const header = document.createElement('div');
                header.className = 'group-header';
                header.textContent = `${selectedCategory} (${filtered.length})`;
                section.appendChild(header);
                
                const groupGrid = document.createElement('div');
                const hasEPG = Object.keys(epgData).length > 0 && currentMode === 'live';
                groupGrid.className = hasEPG ? 'group-channels list-mode' : 'group-channels';
                
                filtered.forEach((channel, index) => {
                    const card = document.createElement('div');
                    card.className = hasEPG ? 'channel-card list-mode' : 'channel-card';
                    card.tabIndex = 0;
                    card.setAttribute('role', 'button');
                    card.setAttribute('aria-label', `${channel.name} (${channel.group})`);
                    const currentProg = getCurrentProgram(channel.tvgId, channel.name);
                    if (hasEPG && currentProg) {
                        const startTime = new Date(currentProg.start).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });
                        const stopTime = currentProg.stop ? new Date(currentProg.stop).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false }) : '';
                        const timeStr = stopTime ? `${startTime} - ${stopTime}` : startTime;
                        card.innerHTML = `
                            <div class="channel-info">
                                <div class="channel-name">${escapeHtml(channel.name)}</div>
                                <div class="channel-group">${escapeHtml(channel.group)}</div>
                            </div>
                            <div class="epg-info">
                                <div class="epg-title">${escapeHtml(currentProg.title)}</div>
                                <div class="epg-time">${timeStr}</div>
                                ${currentProg.desc ? `<div class="epg-desc">${escapeHtml(currentProg.desc)}</div>` : ''}
                            </div>
                        `;
                    } else if (hasEPG) {
                        card.innerHTML = `
                            <div class="channel-info">
                                <div class="channel-name">${escapeHtml(channel.name)}</div>
                                <div class="channel-group">${escapeHtml(channel.group)}</div>
                            </div>
                            <div class="epg-info">
                                <div class="epg-time" style="color: #6b7280;">No program info</div>
                            </div>
                        `;
                    } else {
                        card.innerHTML = `
                            <div class="channel-name">${escapeHtml(channel.name)}</div>
                            <div class="channel-group">${escapeHtml(channel.group)}</div>
                        `;
                    }
                    
                    card.onclick = () => playChannel(channel);
                    card.onkeydown = (e) => {
                        if (e.key === 'Enter') playChannel(channel);
                    };
                    groupGrid.appendChild(card);
                });
                
                section.appendChild(groupGrid);
                grid.appendChild(section);
            }
        }
        
        // Render category buttons
        function renderCategories() {
            const container = document.getElementById('categories');
            if (!container) return;
            container.innerHTML = '';

            const base = getChannelsForCurrentMode();
            if (!base || base.length === 0) {
                return;
            }
            
            // Get unique categories for current mode
            const categorySet = {};
            for (let i = 0; i < base.length; i++) {
                const g = base[i].group || 'General';
                categorySet[g] = true;
            }
            const groups = Object.keys(categorySet).sort();
            const categories = ['All'].concat(groups);
            
            categories.forEach(category => {
                const btn = document.createElement('button');
                btn.className = 'category-btn' + (category === selectedCategory ? ' active' : '');
                const count = category === 'All'
                    ? base.length
                    : base.filter(ch => ch.group === category).length;
                btn.textContent = `${category} (${count})`;
                btn.tabIndex = 0;
                btn.onclick = (e) => {
                    selectedCategory = category;
                    renderCategories();
                    renderChannels();
                    updateStatus(`Showing ${category} ${currentMode === 'vod' ? 'VOD' : 'Live TV'} channels`);
                    // Keep focus on the clicked category button
                    const targetBtn = e.currentTarget;
                    if (targetBtn) {
                        setTimeout(() => {
                            targetBtn.focus();
                        }, 0);
                    }
                };
                container.appendChild(btn);
            });
        }

        function setMode(mode) {
            if (mode !== 'live' && mode !== 'vod') return;
            if (currentMode === mode) return;
            currentMode = mode;

            const liveBtn = document.getElementById('mode-live');
            const vodBtn = document.getElementById('mode-vod');
            if (liveBtn && vodBtn) {
                if (mode === 'live') {
                    liveBtn.classList.add('active');
                    vodBtn.classList.remove('active');
                } else {
                    vodBtn.classList.add('active');
                    liveBtn.classList.remove('active');
                }
            }

            // Reset category to All when switching modes to avoid empty views
            selectedCategory = 'All';
            renderCategories();
            renderChannels();
            updateStatus(`Showing ${mode === 'vod' ? 'VOD' : 'Live TV'} channels`);
        }
        
        // Get next program for a channel
        function getNextProgram(channelId, channelName) {
            const now = Date.now();
            let programs = null;
            
            // Try exact match with tvg-id first
            if (channelId && epgData[channelId]) {
                programs = epgData[channelId];
            }
            // Try exact match by channel name
            else if (channelName && epgData[channelName]) {
                programs = epgData[channelName];
            }
            // Try fuzzy matching
            else if (channelName) {
                const normalized = channelName
                    .replace(/^(CA|UK|US|AU|NZ|INT|EIR):\s*/i, '')
                    .replace(/\s*\(.*?\)/g, '')
                    .replace(/\s*HD$/i, '')
                    .replace(/\s*FHD$/i, '')
                    .replace(/\s*SD$/i, '')
                    .replace(/\s*4K$/i, '')
                    .replace(/\s+/g, '')
                    .trim()
                    .toLowerCase();
                
                for (const epgChannel in epgData) {
                    const epgCore = epgChannel
                        .replace(/\.(uk|us|ca|au|nz|int)$/i, '')
                        .replace(/hd$/i, '')
                        .replace(/fhd$/i, '')
                        .replace(/sd$/i, '')
                        .replace(/plus1$/i, '')
                        .replace(/\+1$/i, '')
                        .toLowerCase();
                    
                    if (normalized === epgCore || normalized.includes(epgCore) || epgCore.includes(normalized)) {
                        programs = epgData[epgChannel];
                        break;
                    }
                }
            }
            
            if (!programs || programs.length === 0) return null;
            
            // Find the next program (starts after now)
            for (let i = 0; i < programs.length; i++) {
                const prog = programs[i];
                if (prog.start > now) {
                    return prog;
                }
            }
            
            return null;
        }
        
        // Update banner view (now or next)
        function updateBannerView() {
            const nowSection = document.getElementById('banner-now-section');
            const nextSection = document.getElementById('banner-next-section');
            const indicators = document.getElementById('banner-indicators');
            const indicatorNow = document.getElementById('indicator-now');
            const indicatorNext = document.getElementById('indicator-next');
            const nowLabel = document.getElementById('banner-now-label');
            const nextLabel = document.getElementById('banner-next-label');
            
            // Update labels with arrows to show navigation
            if (bannerHasNext) {
                nowLabel.textContent = '< NOW >';
                nextLabel.textContent = '< NEXT >';
            } else {
                nowLabel.textContent = 'NOW';
                nextLabel.textContent = 'NEXT';
            }
            
            if (bannerView === 'now') {
                nowSection.style.display = 'block';
                nextSection.style.display = 'none';
                indicatorNow.classList.add('active');
                indicatorNext.classList.remove('active');
            } else {
                nowSection.style.display = 'none';
                nextSection.style.display = 'block';
                indicatorNow.classList.remove('active');
                indicatorNext.classList.add('active');
            }
            
            // Show indicators only if there's a next program
            indicators.style.display = bannerHasNext ? 'flex' : 'none';
        }
        
        // Show channel banner with EPG info
        function showChannelBanner(channel, resetView = true) {
            const banner = document.getElementById('channel-banner');
            const channelName = document.getElementById('banner-channel-name');
            const nowSection = document.getElementById('banner-now-section');
            const nextSection = document.getElementById('banner-next-section');
            const epgTitle = document.getElementById('banner-epg-title');
            const epgTime = document.getElementById('banner-epg-time');
            const epgDesc = document.getElementById('banner-epg-desc');
            const progressContainer = document.getElementById('banner-progress');
            const progressBar = document.getElementById('banner-progress-bar');
            const nextTitle = document.getElementById('banner-next-title');
            const nextTime = document.getElementById('banner-next-time');
            const nextDesc = document.getElementById('banner-next-desc');
            const bannerTime = document.getElementById('banner-time');
            const bannerDate = document.getElementById('banner-date');
            
            if (!banner) return;
            
            // Reset view to 'now' when first showing banner
            if (resetView) {
                bannerView = 'now';
            }
            
            // Set channel name
            channelName.textContent = channel.name;
            
            // Set current date and time
            const now = new Date();
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            const dayName = days[now.getDay()];
            const month = months[now.getMonth()];
            const date = now.getDate();
            const year = now.getFullYear();
            
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            
            if (bannerTime) bannerTime.textContent = `${hours}:${minutes}`;
            if (bannerDate) bannerDate.textContent = `${dayName} ${month} ${date} ${year}`;
            
            // Only show EPG for live TV
            if (channel.type === 'live' && Object.keys(epgData).length > 0) {
                const currentProg = getCurrentProgram(channel.tvgId, channel.name);
                const nextProg = getNextProgram(channel.tvgId, channel.name);
                
                bannerHasNext = !!nextProg;
                
                if (currentProg) {
                    const startTime = new Date(currentProg.start).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });
                    const stopTime = currentProg.stop ? new Date(currentProg.stop).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false }) : '';
                    const timeStr = stopTime ? `${startTime} - ${stopTime}` : startTime;
                    
                    epgTitle.textContent = currentProg.title;
                    epgTime.textContent = timeStr;
                    epgDesc.textContent = currentProg.desc || '';
                    epgDesc.style.display = currentProg.desc ? 'block' : 'none';
                    
                    // Calculate and show progress bar
                    if (currentProg.start && currentProg.stop) {
                        const now = Date.now();
                        const duration = currentProg.stop - currentProg.start;
                        const elapsed = now - currentProg.start;
                        const progress = Math.max(0, Math.min(100, (elapsed / duration) * 100));
                        
                        progressBar.style.width = progress + '%';
                        progressContainer.style.display = 'block';
                    } else {
                        progressContainer.style.display = 'none';
                    }
                } else {
                    // No current program
                    bannerHasNext = false;
                }
                
                // Populate next program data
                if (nextProg) {
                    const startTime = new Date(nextProg.start).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });
                    const stopTime = nextProg.stop ? new Date(nextProg.stop).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false }) : '';
                    const timeStr = stopTime ? `${startTime} - ${stopTime}` : startTime;
                    
                    nextTitle.textContent = nextProg.title;
                    nextTime.textContent = timeStr;
                    nextDesc.textContent = nextProg.desc || '';
                    nextDesc.style.display = nextProg.desc ? 'block' : 'none';
                }
            } else {
                bannerHasNext = false;
            }
            
            // Update view based on current selection
            updateBannerView();
            
            // Show banner
            banner.classList.add('visible');
            
            // Clear existing timeout
            if (bannerTimeout) {
                clearTimeout(bannerTimeout);
            }
            
            // Hide after 7 seconds
            bannerTimeout = setTimeout(() => {
                banner.classList.remove('visible');
                bannerTimeout = null;
            }, 7000);
        }
        
        // Play channel
        function playChannel(channel) {
            const playerContainer = document.getElementById('player-container');
            const video = document.getElementById('video-player');
            const title = document.getElementById('player-title');
            
            console.log('Playing channel:', channel.name, 'URL:', channel.url);
            
            // Store current channel for info banner and track index
            currentPlayingChannel = channel;
            currentChannelIndex = channels.indexOf(channel);
            
            // Add history state so back button works within app
            window.history.pushState({ player: true, channel: channel.name }, '', '');
            
            playerContainer.classList.add('active');
            window.playerActive = true; // Set global flag
            title.textContent = channel.name;
            
            // Clean up previous HLS instance
            if (hls) {
                hls.destroy();
                hls = null;
            }
            
            video.src = '';
            video.load();
            
            // Play stream
            const streamUrl = channel.url;
            const isHLS = streamUrl.includes('.m3u8') || streamUrl.includes('m3u8');
            
            console.log('Stream type:', isHLS ? 'HLS' : 'Direct', 'HLS.isSupported:', Hls.isSupported());
            
            if (isHLS && Hls.isSupported()) {
                console.log('Using HLS.js');
                hls = new Hls({
                    enableWorker: false,
                    backBufferLength: 30,
                    maxBufferLength: 30,
                    debug: false
                });
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('Manifest parsed, starting playback');
                    video.play().catch(e => console.error('Play failed:', e));
                });
                
                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS Error:', data.type, data.details);
                    if (data.fatal) {
                        console.error('Fatal error:', data);
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.log('Network error, trying to recover...');
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log('Media error, trying to recover...');
                                hls.recoverMediaError();
                                break;
                            default:
                                console.error('Cannot recover from error');
                                updateStatus(`Error: ${data.details}`);
                                break;
                        }
                    }
                });
                
                hls.loadSource(streamUrl);
                hls.attachMedia(video);
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                console.log('Using native HLS');
                video.src = streamUrl;
                video.play().catch(e => console.error('Play failed:', e));
            } else {
                console.log('Direct video playback');
                video.src = streamUrl;
                video.play().catch(e => console.error('Play failed:', e));
            }
            
            video.onerror = (e) => {
                console.error('Video error:', e, 'Network state:', video.networkState, 'Ready state:', video.readyState);
                updateStatus(`Video error: ${video.error ? video.error.message : 'Unknown'}`);
            };
            
            video.onloadedmetadata = () => {
                console.log('Video metadata loaded:', video.videoWidth, 'x', video.videoHeight);
            };
            
            video.oncanplay = () => {
                console.log('Video can play');
            };
            
            // Show channel banner when video starts playing (removed fullscreen request)
            video.onplaying = () => {
                console.log('Video is playing');
                // Show channel banner with EPG info
                showChannelBanner(channel);
            };
            
            updateStatus(`Playing: ${channel.name}`);
        }
        
        // Navigate to next/previous channel
        function changeChannel(direction) {
            if (!currentPlayingChannel || currentChannelIndex === -1 || channels.length === 0) {
                return;
            }
            
            let newIndex = currentChannelIndex + direction;
            
            // Wrap around
            if (newIndex >= channels.length) {
                newIndex = 0;
            } else if (newIndex < 0) {
                newIndex = channels.length - 1;
            }
            
            const newChannel = channels[newIndex];
            if (newChannel) {
                console.log('Changing channel:', direction > 0 ? 'up' : 'down', 'to', newChannel.name);
                playChannel(newChannel);
            }
        }
        
        // Close player
        function closePlayer() {
            const playerContainer = document.getElementById('player-container');
            const video = document.getElementById('video-player');
            
            console.log('closePlayer called');
            playerContainer.classList.remove('active');
            window.playerActive = false; // Clear global flag
            currentPlayingChannel = null; // Clear current channel
            currentChannelIndex = -1; // Clear channel index
            video.pause();
            
            if (hls) {
                hls.destroy();
                hls = null;
            }
        }
        
        // Update status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Update date and time display
        function updateDateTime() {
            const now = new Date();
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            const dayName = days[now.getDay()];
            const month = months[now.getMonth()];
            const date = now.getDate();
            const year = now.getFullYear();
            
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            
            const timeEl = document.getElementById('time-display');
            const dateEl = document.getElementById('date-display');
            
            if (timeEl) timeEl.textContent = `${hours}:${minutes}`;
            if (dateEl) dateEl.textContent = `${dayName} ${month} ${date} ${year}`;
        }
        
        // Update time every second
        setInterval(updateDateTime, 1000);
        updateDateTime(); // Initial update

        // Show environment info (user agent and HLS capabilities)
        function showEnvironmentInfo() {
            const infoEl = document.getElementById('env-info');
            if (!infoEl) return;
            
            const ua = navigator.userAgent || 'Unknown';
            const tempVideo = document.createElement('video');
            const hlsJsSupported = typeof Hls !== 'undefined' && Hls.isSupported && Hls.isSupported();
            const nativeHls = !!(
                tempVideo.canPlayType && (
                    tempVideo.canPlayType('application/vnd.apple.mpegurl') ||
                    tempVideo.canPlayType('application/x-mpegURL')
                )
            );
            
            const lines = [
                `UA: ${ua}`,
                `Hls.js supported: ${hlsJsSupported}`,
                `Native HLS support: ${nativeHls}`
            ];
            
            console.log('Environment info:', { ua, hlsJsSupported, nativeHls });
            infoEl.innerHTML = lines.map(line => escapeHtml(line)).join('<br>');
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Clear cache
        function clearCache() {
            localStorage.clear();
            channels = [];
            selectedCategory = 'All';
            // Hide Live TV / VOD mode buttons when cache is cleared in settings
            if (typeof setModeToggleVisibility === 'function') {
                setModeToggleVisibility(false);
            } else {
                const modeToggle = document.getElementById('mode-toggle');
                if (modeToggle) modeToggle.style.display = 'none';
            }
            renderChannels();
            renderCategories();
            updateStatus('Cache cleared');
            // Restore sensible focus so remote D-pad navigation still works
            try {
                const settingsBtn = document.getElementById('settings-btn');
                if (settingsBtn && typeof settingsBtn.focus === 'function') {
                    // Small delay to allow DOM updates to finish
                    setTimeout(() => {
                        settingsBtn.focus();
                        // Add a short-lived highlight so remote users see the focus target
                        settingsBtn.classList.add('highlighted');
                        setTimeout(() => settingsBtn.classList.remove('highlighted'), 3600);
                    }, 40);
                } else {
                    // Fallback: focus the landing container
                    const landing = document.getElementById('landing');
                    if (landing && typeof landing.focus === 'function') {
                        setTimeout(() => landing.focus(), 40);
                    }
                }
            } catch (e) {
                console.warn('Could not restore focus after clearing cache', e);
            }
        }

        // Settings navigation
        function openSettings() {
            const panel = document.getElementById('settings-panel');
            if (!panel) return;
            
            // Add history state so back button works
            window.history.pushState({ settings: true }, '', '');
            
            panel.classList.add('active');
            window.settingsActive = true;
            // Focus first input in settings for remote navigation
            setTimeout(() => {
                const firstInput = panel.querySelector('#m3u-url, input, button');
                if (firstInput && typeof firstInput.focus === 'function') {
                    firstInput.focus();
                }
            }, 50);
        }
        
        function closeSettings() {
            const panel = document.getElementById('settings-panel');
            if (!panel) return;
            
            panel.classList.remove('active');
            window.settingsActive = false;
        }
        
        // Event listeners
        document.getElementById('load-btn').onclick = loadPlaylist;
        document.getElementById('load-epg-btn').onclick = loadEPG;
        document.getElementById('clear-btn').onclick = clearCache;
        document.getElementById('close-player').onclick = closePlayer;
        document.getElementById('close-settings').onclick = closeSettings;
        document.getElementById('settings-btn').onclick = openSettings;
        
        // Listen for custom closePlayer event from history.back override
        document.addEventListener('closePlayer', function() {
            console.log('Custom closePlayer event triggered');
            closePlayer();
        });
        
        // Handle popstate (back button via history API)
        window.addEventListener('popstate', function(e) {
            console.log('popstate event:', e.state);
            const playerContainer = document.getElementById('player-container');
            const settingsPanel = document.getElementById('settings-panel');
            const isPlayerActive = playerContainer && playerContainer.classList.contains('active');
            const isSettingsActive = settingsPanel && settingsPanel.classList.contains('active');
            
            if (isPlayerActive) {
                console.log('Back button pressed while player active - closing player');
                closePlayer();
            } else if (isSettingsActive) {
                console.log('Back button pressed while settings active - closing settings');
                closeSettings();
            }
        });

        const modeLiveBtn = document.getElementById('mode-live');
        const modeVodBtn = document.getElementById('mode-vod');
        if (modeLiveBtn) {
            modeLiveBtn.onclick = () => setMode('live');
        }
        if (modeVodBtn) {
            modeVodBtn.onclick = () => setMode('vod');
        }
        
        // Handle webOS back button using webOSDev API
        if (window.webOSDev) {
            console.log('webOSDev detected, setting up back button handler');
            window.webOSDev.WEBOS_SERVICE_SUBSCRIPTION = false;
            
            // Override the back button behavior
            window.addEventListener('keydown', function(e) {
                const playerContainer = document.getElementById('player-container');
                const isPlayerActive = playerContainer && playerContainer.classList.contains('active');
                console.log('webOSDev keydown:', e.keyCode, 'Player active:', isPlayerActive);
                
                if (e.keyCode === 461 && isPlayerActive) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    closePlayer();
                }
            }, true);
        }
        
        // Handle webOS back button at window level
        window.addEventListener('keydown', (e) => {
            const playerContainer = document.getElementById('player-container');
            const isPlayerActive = playerContainer && playerContainer.classList.contains('active');
            console.log('Window keydown:', e.key, e.keyCode, 'Player active:', isPlayerActive);
            
            if (e.keyCode === 461 && isPlayerActive) {
                e.preventDefault();
                e.stopPropagation();
                closePlayer();
                return false;
            }
        }, true);
        
        // Try to prevent app closure when player is active
        window.onbeforeunload = function(e) {
            const playerContainer = document.getElementById('player-container');
            const isPlayerActive = playerContainer && playerContainer.classList.contains('active');
            console.log('Before unload, player active:', isPlayerActive);
            
            if (isPlayerActive) {
                closePlayer();
                e.preventDefault();
                e.returnValue = '';
                return '';
            }
        };
        
        // Remote control navigation
        document.addEventListener('keydown', (e) => {
            const playerContainer = document.getElementById('player-container');
            const isPlayerActive = playerContainer.classList.contains('active');
            const settingsPanel = document.getElementById('settings-panel');
            const isSettingsOpen = settingsPanel && settingsPanel.classList.contains('active');
            
            console.log('Key pressed:', e.key, 'keyCode:', e.keyCode, 'Player active:', isPlayerActive, 'Settings open:', isSettingsOpen);
            
            // Back button - Exit player or close settings
            // Support multiple key codes: Escape, Backspace, webOS Back (461), Samsung Back (10009)
            if (e.key === 'Escape' || e.key === 'Backspace' || e.key === 'Back' || e.keyCode === 461 || e.keyCode === 10009 || e.keyCode === 27 || e.keyCode === 8) {
                if (isPlayerActive || isSettingsOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('Back button intercepted, closing player/settings');
                    if (isPlayerActive) {
                        closePlayer();
                    } else if (isSettingsOpen) {
                        closeSettings();
                    }
                    return false;
                }
                // Don't prevent default if nothing is open - let the app exit normally
                console.log('Back button - letting app exit');
            }
            
            // When player is active, Enter/OK/Up shows info banner, left/right navigate banner, channel up/down changes channel
            if (isPlayerActive) {
                const banner = document.getElementById('channel-banner');
                const isBannerVisible = banner && banner.classList.contains('visible');
                
                // Enter/OK or Up key shows info banner
                if (e.key === 'Enter' || e.keyCode === 13 || e.key === 'ArrowUp' || e.keyCode === 38) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    if (currentPlayingChannel) {
                        console.log('Showing info banner for current channel');
                        showChannelBanner(currentPlayingChannel);
                    }
                    return false;
                }

                // Down key hides info banner
                if ((e.key === 'ArrowDown' || e.keyCode === 40) && isBannerVisible) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('Hiding info banner via Down key');
                    banner.classList.remove('visible');
                    if (bannerTimeout) {
                        clearTimeout(bannerTimeout);
                        bannerTimeout = null;
                    }
                    return false;
                }
                
                // Channel Up key (keyCode 427 on webOS/Samsung, or PageUp 33)
                if (e.keyCode === 427 || e.keyCode === 33 || e.key === 'PageUp' || e.key === 'ChannelUp') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('Channel Up pressed - changing to next channel');
                    changeChannel(1);
                    return false;
                }
                
                // Channel Down key (keyCode 428 on webOS/Samsung, or PageDown 34)
                if (e.keyCode === 428 || e.keyCode === 34 || e.key === 'PageDown' || e.key === 'ChannelDown') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('Channel Down pressed - changing to previous channel');
                    changeChannel(-1);
                    return false;
                }
                
                // Navigate between Now and Next with left/right arrows when banner is visible
                if (isBannerVisible && bannerHasNext) {
                    if (e.key === 'ArrowLeft' || e.keyCode === 37) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        if (bannerView === 'next') {
                            bannerView = 'now';
                            updateBannerView();
                            // Reset timeout
                            if (bannerTimeout) clearTimeout(bannerTimeout);
                            bannerTimeout = setTimeout(() => {
                                banner.classList.remove('visible');
                                bannerTimeout = null;
                            }, 7000);
                        }
                        return false;
                    }
                    if (e.key === 'ArrowRight' || e.keyCode === 39) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        if (bannerView === 'now') {
                            bannerView = 'next';
                            updateBannerView();
                            // Reset timeout
                            if (bannerTimeout) clearTimeout(bannerTimeout);
                            bannerTimeout = setTimeout(() => {
                                banner.classList.remove('visible');
                                bannerTimeout = null;
                            }, 7000);
                        }
                        return false;
                    }
                }
                
                return;
            }
            
            // Arrow key navigation
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();
                const focused = document.activeElement;

                // If settings panel is open, navigate among its focusable controls
                if (isSettingsOpen) {
                    const panel = settingsPanel;
                    // collect visible focusable controls
                    const selector = 'button, input, select, textarea, [tabindex]';
                    const allElements = Array.from(panel.querySelectorAll(selector)).filter(el => {
                        if (!(el.offsetParent !== null)) return false; // visible
                        if (el.getAttribute('tabindex') === '-1') return false;
                        return true;
                    });

                    // If nothing focused or focused element not in settings, focus first
                    if (!focused || !panel.contains(focused)) {
                        if (allElements.length > 0) allElements[0].focus();
                        return;
                    }

                    const currentIndex = allElements.indexOf(focused);
                    if (currentIndex === -1) return;

                    const rect = focused.getBoundingClientRect();
                    let bestIndex = -1;
                    let bestDistance = Infinity;

                    allElements.forEach((element, index) => {
                        if (index === currentIndex) return;
                        const targetRect = element.getBoundingClientRect();
                        let isValid = false;
                        let distance = 0;

                        if (e.key === 'ArrowUp') {
                            isValid = targetRect.bottom <= rect.top + 10;
                            distance = rect.top - targetRect.bottom + Math.abs(targetRect.left - rect.left) * 0.3;
                        } else if (e.key === 'ArrowDown') {
                            isValid = targetRect.top >= rect.bottom - 10;
                            distance = targetRect.top - rect.bottom + Math.abs(targetRect.left - rect.left) * 0.3;
                        } else if (e.key === 'ArrowLeft') {
                            isValid = targetRect.right <= rect.left + 10;
                            distance = rect.left - targetRect.right + Math.abs(targetRect.top - rect.top) * 0.3;
                        } else if (e.key === 'ArrowRight') {
                            isValid = targetRect.left >= rect.right - 10;
                            distance = targetRect.left - rect.right + Math.abs(targetRect.top - rect.top) * 0.3;
                        }

                        if (isValid && distance < bestDistance) {
                            bestDistance = distance;
                            bestIndex = index;
                        }
                    });

                    if (bestIndex !== -1) {
                        allElements[bestIndex].focus();
                        allElements[bestIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                    }

                    return;
                }

                // Default navigation across category buttons and channel cards
                const focusedDefault = document.activeElement;
                if (!focusedDefault || (!focusedDefault.classList.contains('channel-card') && !focusedDefault.classList.contains('category-btn'))) {
                    // Focus first element if nothing is focused
                    const firstCard = document.querySelector('.channel-card');
                    if (firstCard) firstCard.focus();
                    return;
                }

                // Get all focusable elements
                const allElements = Array.from(document.querySelectorAll('.category-btn, .channel-card'));
                const currentIndex = allElements.indexOf(focusedDefault);

                if (currentIndex === -1) return;

                const rect = focusedDefault.getBoundingClientRect();
                let bestIndex = -1;
                let bestDistance = Infinity;

                // Find best element in the direction
                allElements.forEach((element, index) => {
                    if (index === currentIndex) return;

                    const targetRect = element.getBoundingClientRect();
                    let isValid = false;
                    let distance = 0;

                    if (e.key === 'ArrowUp') {
                        isValid = targetRect.bottom <= rect.top + 10;
                        distance = rect.top - targetRect.bottom + Math.abs(targetRect.left - rect.left) * 0.3;
                    } else if (e.key === 'ArrowDown') {
                        isValid = targetRect.top >= rect.bottom - 10;
                        distance = targetRect.top - rect.bottom + Math.abs(targetRect.left - rect.left) * 0.3;
                    } else if (e.key === 'ArrowLeft') {
                        isValid = targetRect.right <= rect.left + 10;
                        distance = rect.left - targetRect.right + Math.abs(targetRect.top - rect.top) * 0.3;
                    } else if (e.key === 'ArrowRight') {
                        isValid = targetRect.left >= rect.right - 10;
                        distance = targetRect.left - rect.right + Math.abs(targetRect.top - rect.top) * 0.3;
                    }

                    if (isValid && distance < bestDistance) {
                        bestDistance = distance;
                        bestIndex = index;
                    }
                });

                if (bestIndex !== -1) {
                    allElements[bestIndex].focus();
                    allElements[bestIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                }
            }
            
            // Enter key - activate focused element
            if (e.key === 'Enter') {
                e.preventDefault();
                const focused = document.activeElement;
                const settingsPanel = document.getElementById('settings-panel');
                const isSettingsOpenLocal = settingsPanel && settingsPanel.classList.contains('active');
                if (isSettingsOpenLocal && focused && (focused.tagName === 'INPUT' || focused.tagName === 'TEXTAREA')) {
                    // If Enter pressed while typing in settings input, trigger Load Playlist
                    const loadBtnLocal = document.getElementById('load-btn');
                    if (loadBtnLocal) {
                        loadBtnLocal.click();
                    }
                } else if (focused) {
                    focused.click();
                }
            }
        }, true); // Use capture phase to intercept events before webOS
        
        // Helper: focus + visually highlight the settings button for a short duration
        function highlightSettingsButton(duration = 3600) {
            try {
                const btn = document.getElementById('settings-btn');
                if (!btn) return;
                if (typeof btn.focus === 'function') btn.focus();
                btn.classList.add('highlighted');
                setTimeout(() => {
                    try { btn.classList.remove('highlighted'); } catch (e) {}
                }, duration);
            } catch (e) {
                console.warn('highlightSettingsButton failed', e);
            }
        }

        // Load cached channels on startup and show environment info
        showEnvironmentInfo();
        loadFromCache();
        // Ensure UI state (mode toggle visibility) reflects current channel data
        renderChannels();
        // If we started with no cached channels, make the Settings button obvious
        if (!channels || channels.length === 0) {
            setTimeout(() => highlightSettingsButton(3600), 60);
        }
        
        // Auto-load EPG if URL is configured
        const cachedEPGUrl = localStorage.getItem('simple-iptv-epg-url');
        if (cachedEPGUrl) {
            console.log('Auto-loading EPG data from configured URL...');
            setTimeout(() => {
                loadEPG();
            }, 1000); // Small delay to let the UI render first
        }
        
        console.log('Simple IPTV Test App Ready');
        console.log('Channels in cache:', channels.length);
    </script>
</body>
</html>
